```{r include=FALSE, cache=FALSE}
set.seed(31415)
options(digits = 3)

knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold"
)

options(dplyr.print_min = 6, dplyr.print_max = 6)
Sys.setenv(LANGUAGE = "en")
```
# Strings

This section covers basic string manipulation in R.  See Chapter 11 in [R for Data Science](http://r4ds.had.co.nz/strings.html) for a more complete coverage.  The first part of this chapter will probably look familiar, but the rest will focus on **regular expressions**.  Regular expressions (sometimes referred to as **regex** or **regexp**) are a concise language for describing patterns in strings.

While base R has some string functions they tend to be inconsistent in the order of the parameters, which makes them hard to remember and you end up needing the help files.  As with most of this course we will focus on the Tidyverse, and in particular the **stringr** package, which in not part of the core tidyverse package so you will have to load it explicitly with `library(stringr)`

```{r, message=FALSE}
library(tidyverse)
library(stringr)
```

## String Basics

As with most languages you create a string by putting the text in single or double quotes `x <- "This is my string!"`, and you can create a vector of strings with `c()`.  There are a handful of special characters but the most common are the newline character `"\n"`, and the tab character `"\t"`.  You may also see strings like `\u00AE` or `\u00b5` which is a way of including non-English characters or special symbols that work on all platforms.  These are typically known as Unicode characters.

```{r}
x <- "This my registered\u00AE drug"
x
```

One nice feature of the stringr package is all string functions begin with `str_`.  This makes it easy in RStudio to find useful string processing functions.

```{block2, type='rmdtip'}
See the tidyverse package **glue** which can glue strings to data in R. Small, fast, dependency free interpreted string literals.
```

### Helpful Basic String functions

-    `str_to_upper()` converts the string to all uppercase characters
-    `str_to_lower()` converts the string to all lowercase characters
-    `str_to_title()` capitalizes the first character of each word in the string
-    `str_c()`        joins multiple strings together into a single string (similar to `paste` or `paste0 from base R)
-    `str_length()`   the length of a string
-    `str_wrap()`     wrap strings into nicely formatted paragraphs
-    `str_trim()`     trim white space from a string
-    `str_pad()`      pad a string
-    `str_order()`    order a character vector
-    `str_sort()`     sort a character vector
-    `str_sub()`      extract and replace substrings from a character vector

```{block type='rmdcaution'}
While `str_c` looks and acts very similar to the base R functions `paste` or `paste0`, they act very differently with regards to missing data.  `paste` and `paste0` replace missing values with the text "NA", while `str_c` propagates the missing value.
```

```{r}
str_c("This", "is", "a", "string", NA, "with", "a", "missing", "value")
paste("This", "is", "a", "string", NA, "with", "a", "missing", "value")
```

Notice `str_c` and `paste` have both a `sep` and `collapse` argument.  While these appear to be the same they are not.  The `sep` argument is the string inserted between arguments to `str_c`, while `collapse` is the string used to separate any elements of the character vector into a character vector of length one.

```{r}
x <- c("This", "is", "a", "character", "vector")
x
str_c("This", "is", "not", "a", "character", "vector", sep = "_")
str_c(x, sep = "_")
str_c(x, collapse = "_")
```

## Regular Expressions

A regular expression (regex or regexp for short) is a special text string for describing a search pattern. Usually this pattern is then used by string searching algorithms for "find" or "find and replace" operations on strings. Patterns can be a bit tricky to wrap your head around at first since the most common case is simply looking for a sequence of letters.  Patterns are much more general.  Think about how would you tell a computer to look for any phone number or any email address.

```{block type='rmdnote'}
Just about every modern programming language has the ability to use regular expressions. In SAS regular expressions are implemented in the PRX series of functions such as: PRXMATCH, PRXSEARCH, PRXPARSE, PRXCHANGE.
```

Regexps are a very terse language that allow you to describe patterns in strings. They take a little while to get your head around, but once you understand them, you’ll find them extremely useful.  Any non-trivial regular expression looks likes a cat walked across your keyboard.

```{block2, type='rmdtip'}
To learn regular expressions, use `str_view()` and `str_view_all()`. These functions take a character vector and a regular expression, and show you how they match. 
```


### Basic Matches

We’ll start with very simple regular expressions and then gradually get more and more complicated. Once you’ve mastered pattern matching, you’ll learn how to apply those ideas with various stringr functions.We'll use the buit in fruit dataset.

```{r}
fruit
```

One of the most common uses of regular expressions is to find strings that contain an exact sequence of letters.

```{r}
str_subset(fruit, "berry")
```

This works great for quite a few cases, but what if you wanted to find just "grape" and not "grapefruit"?

```{r}
str_subset(fruit, "grape")
```

### Special Characters

Once you get beyond basic substring matching you need some helpers.  Below is a list of common helpers.

-    `.` match any character (excpet a newline)
-    `^` match the start of the string
-    `$` match the end of the string

So to match "grape" but not "grapefruit" you could do this is a couple ways.

```{r}
str_subset(fruit, "grape$")   # match all words that end in "grape"
str_subset(fruit, "^grape$")  # match all words the start AND end in "grape"
```
 
Find the fruits that have an "a" in them but not ones that have the only "a" as the starting chracter.

```{r}
str_subset(fruit, ".a")
```

If "`.`" matches any character, how do you match the character "`.`"? 

You need to use an "escape" to tell the regular expression you want to match it exactly, not use its special behaviour. Like strings, regexps use the backslash, `\`, to escape special behaviour. So to match an `.`, you need the regexp `\.`. Unfortunately this creates a problem. We use strings to represent regular expressions, and `\` is also used as an escape symbol in strings. So to create the regular expression `\.` we need the string `"\\."`. 

If `\` is used as an escape character in regular expressions, how do you match a literal `\`? Well you need to escape it, creating the regular expression `\\`. To create that regular expression, you need to use a string, which also needs to escape `\`. That means to match a literal `\` you need to write `"\\\\"` --- you need four backslashes to match one!


### Character classes and alternatives

There are a number of special patterns that match more than one character. You’ve already seen `.`, which matches any character apart from a newline. There are many other useful tools:

-    `\d` match any digit
-    [:digits] match any digit
-    `\D` match any non digit
-    `[:alpha:]` match any letter
-    `[:lower:]` match any lowercase letter
-    `[:upper:]` match any uppercase leter
-    `[:alnum:]` match any alpha numeric character.
-    `[:punct:]` match any punctuation (see cheatsheet)
-    `|`         or (ex `ad|e` matches "ad" or "e")
-    `[]`        matches on of (ex `[ade]` matches "a", "d" or "e", equivalent to `a|d|e)
-    `[^]`       match anything but (ex `[^ade]` matches everyting but "a", "d" or "e")
-    `[-]`       match a range (ex `[0-5]` matches nmberes between 0 and 5 inclusive)

```{block2, type='rmdimportant'}
Remember, to create a regular expression containing `\d`, you need to escape the `\` for the string, so you type `"\\d"`.
```

### Repetition

* `?` match zero or 1
* `*` match zero or more
* `+` match one or more
* `{n}`: exactly n
* `{n,}`: n or more
* `{,m}`: at most m
* `{n,m}`: between n and m


### Grouping

Find everything that is not a "berry"

```{r}
str_subset(fruit, "[^(berry)]")
```

Find all the fruits with a double letter 
```{r}
str_subset(fruit, "([:alpha:])\\1")
```

### Helpful Basic String functions

-    `str_view()`     show the first match of a regular expression
-    `str_view_all()` show all matches of a regular expression
-    `str_subset()`   keep strings matching a pattern
-    `str_which()`    find the postions of strings matching a pattern (similar to base R `grep()`)
-    `str_detect()`   detect the presence of strings matching a pattern (similar to base R `grepl()`)

## Tools

### Detect Matches


-    `str_count()`

### Extract Matches

-    `str_subset()`
-    `str_extract()`

### Replaceing Matches


### Splitting
