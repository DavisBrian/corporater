<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Modern R in a Corporate Environment</title>
  <meta name="description" content="This is an original course for RADARS">
  <meta name="generator" content="bookdown 0.7 and GitBook 2.6.7">

  <meta property="og:title" content="Modern R in a Corporate Environment" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="This is an original course for RADARS" />
  <meta name="github-repo" content="DavisBrian/corporater" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Modern R in a Corporate Environment" />
  
  <meta name="twitter:description" content="This is an original course for RADARS" />
  

<meta name="author" content="Brian Davis">


<meta name="date" content="2018-06-04">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="base-r-data-structures.html">
<link rel="next" href="data-visualization.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="css\style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Modern R in a Corporate Environment</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Welcome</a></li>
<li class="part"><span><b>I Preamble</b></span></li>
<li class="chapter" data-level="1" data-path="preamble-intro.html"><a href="preamble-intro.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul>
<li class="chapter" data-level="1.1" data-path="preamble-intro.html"><a href="preamble-intro.html#course-philosophy"><i class="fa fa-check"></i><b>1.1</b> Course Philosophy</a><ul>
<li class="chapter" data-level="1.1.1" data-path="preamble-intro.html"><a href="preamble-intro.html#reproducible-research-approach"><i class="fa fa-check"></i><b>1.1.1</b> Reproducible Research Approach</a></li>
<li class="chapter" data-level="1.1.2" data-path="preamble-intro.html"><a href="preamble-intro.html#fda-validation"><i class="fa fa-check"></i><b>1.1.2</b> FDA Validation</a></li>
<li class="chapter" data-level="1.1.3" data-path="preamble-intro.html"><a href="preamble-intro.html#the-sas-myth"><i class="fa fa-check"></i><b>1.1.3</b> The SAS Myth</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="preamble-intro.html"><a href="preamble-intro.html#prerequisites"><i class="fa fa-check"></i><b>1.2</b> Prerequisites</a></li>
<li class="chapter" data-level="1.3" data-path="preamble-intro.html"><a href="preamble-intro.html#content"><i class="fa fa-check"></i><b>1.3</b> Content</a></li>
<li class="chapter" data-level="1.4" data-path="preamble-intro.html"><a href="preamble-intro.html#structure"><i class="fa fa-check"></i><b>1.4</b> Structure</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="good-practices.html"><a href="good-practices.html"><i class="fa fa-check"></i><b>2</b> Good practices</a><ul>
<li class="chapter" data-level="2.1" data-path="good-practices.html"><a href="good-practices.html#coding-style"><i class="fa fa-check"></i><b>2.1</b> Coding style</a><ul>
<li class="chapter" data-level="2.1.1" data-path="good-practices.html"><a href="good-practices.html#comments"><i class="fa fa-check"></i><b>2.1.1</b> Comments</a></li>
<li class="chapter" data-level="2.1.2" data-path="good-practices.html"><a href="good-practices.html#naming"><i class="fa fa-check"></i><b>2.1.2</b> Naming</a></li>
<li class="chapter" data-level="2.1.3" data-path="good-practices.html"><a href="good-practices.html#spacing"><i class="fa fa-check"></i><b>2.1.3</b> Spacing</a></li>
<li class="chapter" data-level="2.1.4" data-path="good-practices.html"><a href="good-practices.html#indenting"><i class="fa fa-check"></i><b>2.1.4</b> Indenting</a></li>
<li class="chapter" data-level="2.1.5" data-path="good-practices.html"><a href="good-practices.html#long-lines"><i class="fa fa-check"></i><b>2.1.5</b> Long lines</a></li>
<li class="chapter" data-level="2.1.6" data-path="good-practices.html"><a href="good-practices.html#other"><i class="fa fa-check"></i><b>2.1.6</b> Other</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="good-practices.html"><a href="good-practices.html#coding-practices"><i class="fa fa-check"></i><b>2.2</b> Coding practices</a><ul>
<li class="chapter" data-level="2.2.1" data-path="good-practices.html"><a href="good-practices.html#variables"><i class="fa fa-check"></i><b>2.2.1</b> Variables</a></li>
<li class="chapter" data-level="2.2.2" data-path="good-practices.html"><a href="good-practices.html#rule-of-threedry"><i class="fa fa-check"></i><b>2.2.2</b> <em>Rule of Three</em></a></li>
<li class="chapter" data-level="2.2.3" data-path="good-practices.html"><a href="good-practices.html#path-names"><i class="fa fa-check"></i><b>2.2.3</b> Path names</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="good-practices.html"><a href="good-practices.html#rstudio"><i class="fa fa-check"></i><b>2.3</b> RStudio</a></li>
<li class="chapter" data-level="2.4" data-path="good-practices.html"><a href="good-practices.html#getting-help"><i class="fa fa-check"></i><b>2.4</b> Getting help</a><ul>
<li class="chapter" data-level="2.4.1" data-path="good-practices.html"><a href="good-practices.html#help-yourself-learn-how-to-debug"><i class="fa fa-check"></i><b>2.4.1</b> Help yourself, learn how to debug</a></li>
<li class="chapter" data-level="2.4.2" data-path="good-practices.html"><a href="good-practices.html#external-help"><i class="fa fa-check"></i><b>2.4.2</b> External help</a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="good-practices.html"><a href="good-practices.html#keeping-up-to-date"><i class="fa fa-check"></i><b>2.5</b> Keeping up to date</a></li>
<li class="chapter" data-level="2.6" data-path="good-practices.html"><a href="good-practices.html#exercises"><i class="fa fa-check"></i><b>2.6</b> Exercises</a></li>
</ul></li>
<li class="part"><span><b>II Base R Basics</b></span></li>
<li class="chapter" data-level="3" data-path="baser-rbasics.html"><a href="baser-rbasics.html"><i class="fa fa-check"></i><b>3</b> R Basics</a><ul>
<li class="chapter" data-level="3.1" data-path="baser-rbasics.html"><a href="baser-rbasics.html#assignment-operators"><i class="fa fa-check"></i><b>3.1</b> Assignment Operators</a></li>
<li class="chapter" data-level="3.2" data-path="baser-rbasics.html"><a href="baser-rbasics.html#objects"><i class="fa fa-check"></i><b>3.2</b> Objects</a><ul>
<li class="chapter" data-level="3.2.1" data-path="baser-rbasics.html"><a href="baser-rbasics.html#vector"><i class="fa fa-check"></i><b>3.2.1</b> Vector</a></li>
<li class="chapter" data-level="3.2.2" data-path="baser-rbasics.html"><a href="baser-rbasics.html#matrix"><i class="fa fa-check"></i><b>3.2.2</b> Matrix</a></li>
<li class="chapter" data-level="3.2.3" data-path="baser-rbasics.html"><a href="baser-rbasics.html#list"><i class="fa fa-check"></i><b>3.2.3</b> List</a></li>
<li class="chapter" data-level="3.2.4" data-path="baser-rbasics.html"><a href="baser-rbasics.html#data-frame"><i class="fa fa-check"></i><b>3.2.4</b> Data frame</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="baser-rbasics.html"><a href="baser-rbasics.html#comparision"><i class="fa fa-check"></i><b>3.3</b> Comparision</a></li>
<li class="chapter" data-level="3.4" data-path="baser-rbasics.html"><a href="baser-rbasics.html#logical-and-sets"><i class="fa fa-check"></i><b>3.4</b> Logical and sets</a></li>
<li class="chapter" data-level="3.5" data-path="baser-rbasics.html"><a href="baser-rbasics.html#control-structures"><i class="fa fa-check"></i><b>3.5</b> Control Structures</a><ul>
<li class="chapter" data-level="3.5.1" data-path="baser-rbasics.html"><a href="baser-rbasics.html#if-else"><i class="fa fa-check"></i><b>3.5.1</b> <code>if</code>-<code>else</code></a></li>
<li class="chapter" data-level="3.5.2" data-path="baser-rbasics.html"><a href="baser-rbasics.html#for-loops"><i class="fa fa-check"></i><b>3.5.2</b> <code>for</code> Loops</a></li>
<li class="chapter" data-level="3.5.3" data-path="baser-rbasics.html"><a href="baser-rbasics.html#while-loops"><i class="fa fa-check"></i><b>3.5.3</b> <code>while</code> Loops</a></li>
<li class="chapter" data-level="3.5.4" data-path="baser-rbasics.html"><a href="baser-rbasics.html#repeat-loops"><i class="fa fa-check"></i><b>3.5.4</b> <code>repeat</code> Loops</a></li>
<li class="chapter" data-level="3.5.5" data-path="baser-rbasics.html"><a href="baser-rbasics.html#next-break"><i class="fa fa-check"></i><b>3.5.5</b> <code>next</code>, <code>break</code></a></li>
<li class="chapter" data-level="3.5.6" data-path="baser-rbasics.html"><a href="baser-rbasics.html#looping"><i class="fa fa-check"></i><b>3.5.6</b> Looping</a></li>
</ul></li>
<li class="chapter" data-level="3.6" data-path="baser-rbasics.html"><a href="baser-rbasics.html#vectorization-recycling"><i class="fa fa-check"></i><b>3.6</b> Vectorization &amp; Recycling</a><ul>
<li class="chapter" data-level="3.6.1" data-path="baser-rbasics.html"><a href="baser-rbasics.html#example"><i class="fa fa-check"></i><b>3.6.1</b> Example</a></li>
</ul></li>
<li class="chapter" data-level="3.7" data-path="baser-rbasics.html"><a href="baser-rbasics.html#function-basics"><i class="fa fa-check"></i><b>3.7</b> Function Basics</a><ul>
<li class="chapter" data-level="3.7.1" data-path="baser-rbasics.html"><a href="baser-rbasics.html#your-first-function"><i class="fa fa-check"></i><b>3.7.1</b> Your First Function</a></li>
<li class="chapter" data-level="3.7.2" data-path="baser-rbasics.html"><a href="baser-rbasics.html#lazy-evaluation"><i class="fa fa-check"></i><b>3.7.2</b> Lazy Evaluation</a></li>
<li class="chapter" data-level="3.7.3" data-path="baser-rbasics.html"><a href="baser-rbasics.html#the-...-argument"><i class="fa fa-check"></i><b>3.7.3</b> The <code>...</code> Argument</a></li>
</ul></li>
<li class="chapter" data-level="3.8" data-path="baser-rbasics.html"><a href="baser-rbasics.html#environments-scoping"><i class="fa fa-check"></i><b>3.8</b> Environments &amp; Scoping</a></li>
<li class="chapter" data-level="3.9" data-path="baser-rbasics.html"><a href="baser-rbasics.html#exercises-1"><i class="fa fa-check"></i><b>3.9</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="base-r-data-structures.html"><a href="base-r-data-structures.html"><i class="fa fa-check"></i><b>4</b> Base R Data Structures</a><ul>
<li class="chapter" data-level="4.1" data-path="base-r-data-structures.html"><a href="base-r-data-structures.html#naming-rules"><i class="fa fa-check"></i><b>4.1</b> Naming Rules</a></li>
<li class="chapter" data-level="4.2" data-path="base-r-data-structures.html"><a href="base-r-data-structures.html#vectors"><i class="fa fa-check"></i><b>4.2</b> Vectors</a><ul>
<li class="chapter" data-level="4.2.1" data-path="base-r-data-structures.html"><a href="base-r-data-structures.html#atomic-vectors"><i class="fa fa-check"></i><b>4.2.1</b> Atomic Vectors</a></li>
<li class="chapter" data-level="4.2.2" data-path="base-r-data-structures.html"><a href="base-r-data-structures.html#lists"><i class="fa fa-check"></i><b>4.2.2</b> Lists</a></li>
<li class="chapter" data-level="4.2.3" data-path="base-r-data-structures.html"><a href="base-r-data-structures.html#null"><i class="fa fa-check"></i><b>4.2.3</b> <code>NULL</code></a></li>
<li class="chapter" data-level="4.2.4" data-path="base-r-data-structures.html"><a href="base-r-data-structures.html#attributes"><i class="fa fa-check"></i><b>4.2.4</b> Attributes</a></li>
<li class="chapter" data-level="4.2.5" data-path="base-r-data-structures.html"><a href="base-r-data-structures.html#factors"><i class="fa fa-check"></i><b>4.2.5</b> Factors</a></li>
<li class="chapter" data-level="4.2.6" data-path="base-r-data-structures.html"><a href="base-r-data-structures.html#matrices-and-arrays"><i class="fa fa-check"></i><b>4.2.6</b> Matrices and arrays</a></li>
<li class="chapter" data-level="4.2.7" data-path="base-r-data-structures.html"><a href="base-r-data-structures.html#data-frames"><i class="fa fa-check"></i><b>4.2.7</b> Data Frames</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="subsetting.html"><a href="subsetting.html"><i class="fa fa-check"></i><b>5</b> Subsetting</a><ul>
<li class="chapter" data-level="5.1" data-path="subsetting.html"><a href="subsetting.html#selecting-multiple-elements"><i class="fa fa-check"></i><b>5.1</b> Selecting multiple elements</a><ul>
<li class="chapter" data-level="5.1.1" data-path="subsetting.html"><a href="subsetting.html#atomic-vectors-1"><i class="fa fa-check"></i><b>5.1.1</b> Atomic vectors</a></li>
<li class="chapter" data-level="5.1.2" data-path="subsetting.html"><a href="subsetting.html#matrices-and-arrays-1"><i class="fa fa-check"></i><b>5.1.2</b> Matrices and Arrays</a></li>
<li class="chapter" data-level="5.1.3" data-path="subsetting.html"><a href="subsetting.html#lists-1"><i class="fa fa-check"></i><b>5.1.3</b> Lists</a></li>
<li class="chapter" data-level="5.1.4" data-path="subsetting.html"><a href="subsetting.html#data-frames-1"><i class="fa fa-check"></i><b>5.1.4</b> Data Frames</a></li>
<li class="chapter" data-level="5.1.5" data-path="subsetting.html"><a href="subsetting.html#preserving-dimensionality"><i class="fa fa-check"></i><b>5.1.5</b> Preserving dimensionality</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="subsetting.html"><a href="subsetting.html#selecting-a-single-elements"><i class="fa fa-check"></i><b>5.2</b> Selecting a single elements</a><ul>
<li class="chapter" data-level="5.2.1" data-path="subsetting.html"><a href="subsetting.html#section"><i class="fa fa-check"></i><b>5.2.1</b> <code>$</code></a></li>
<li class="chapter" data-level="5.2.2" data-path="subsetting.html"><a href="subsetting.html#missingout-of-bounds-indices"><i class="fa fa-check"></i><b>5.2.2</b> Missing/out of bounds indices</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="subsetting.html"><a href="subsetting.html#subassignment"><i class="fa fa-check"></i><b>5.3</b> Subsetting and assignment</a></li>
<li class="chapter" data-level="5.4" data-path="subsetting.html"><a href="subsetting.html#applications"><i class="fa fa-check"></i><b>5.4</b> Applications</a><ul>
<li class="chapter" data-level="5.4.1" data-path="subsetting.html"><a href="subsetting.html#lookup-tables-character-subsetting"><i class="fa fa-check"></i><b>5.4.1</b> Lookup tables (character subsetting)</a></li>
<li class="chapter" data-level="5.4.2" data-path="subsetting.html"><a href="subsetting.html#ordering-integer-subsetting"><i class="fa fa-check"></i><b>5.4.2</b> Ordering (integer subsetting)</a></li>
<li class="chapter" data-level="5.4.3" data-path="subsetting.html"><a href="subsetting.html#selecting-rows-based-on-a-condition-logical-subsetting"><i class="fa fa-check"></i><b>5.4.3</b> Selecting rows based on a condition (logical subsetting)</a></li>
<li class="chapter" data-level="5.4.4" data-path="subsetting.html"><a href="subsetting.html#removing-columns-from-data-frames-character-subsetting"><i class="fa fa-check"></i><b>5.4.4</b> Removing columns from data frames (character subsetting)</a></li>
<li class="chapter" data-level="5.4.5" data-path="subsetting.html"><a href="subsetting.html#random-samplesbootstrap-integer-subsetting"><i class="fa fa-check"></i><b>5.4.5</b> Random samples/bootstrap (integer subsetting)</a></li>
<li class="chapter" data-level="5.4.6" data-path="subsetting.html"><a href="subsetting.html#boolean-algebra-vs.sets-logical-integer-subsetting"><i class="fa fa-check"></i><b>5.4.6</b> Boolean algebra vs. sets (logical &amp; integer subsetting)</a></li>
</ul></li>
<li class="chapter" data-level="5.5" data-path="subsetting.html"><a href="subsetting.html#exercises-2"><i class="fa fa-check"></i><b>5.5</b> Exercises</a></li>
</ul></li>
<li class="part"><span><b>III R4DS</b></span></li>
<li class="chapter" data-level="6" data-path="data-visualization.html"><a href="data-visualization.html"><i class="fa fa-check"></i><b>6</b> Data Visualization</a><ul>
<li class="chapter" data-level="6.1" data-path="data-visualization.html"><a href="data-visualization.html#why-ggplot2"><i class="fa fa-check"></i><b>6.1</b> Why ggplot2</a></li>
<li class="chapter" data-level="6.2" data-path="data-visualization.html"><a href="data-visualization.html#example-1"><i class="fa fa-check"></i><b>6.2</b> Example</a><ul>
<li class="chapter" data-level="6.2.1" data-path="data-visualization.html"><a href="data-visualization.html#data"><i class="fa fa-check"></i><b>6.2.1</b> Data</a></li>
<li class="chapter" data-level="6.2.2" data-path="data-visualization.html"><a href="data-visualization.html#aesthetics"><i class="fa fa-check"></i><b>6.2.2</b> Aesthetics</a></li>
<li class="chapter" data-level="6.2.3" data-path="data-visualization.html"><a href="data-visualization.html#geoms"><i class="fa fa-check"></i><b>6.2.3</b> Geoms</a></li>
<li class="chapter" data-level="6.2.4" data-path="data-visualization.html"><a href="data-visualization.html#scales"><i class="fa fa-check"></i><b>6.2.4</b> Scales</a></li>
<li class="chapter" data-level="6.2.5" data-path="data-visualization.html"><a href="data-visualization.html#themes"><i class="fa fa-check"></i><b>6.2.5</b> Themes</a></li>
</ul></li>
<li class="chapter" data-level="6.3" data-path="data-visualization.html"><a href="data-visualization.html#facets"><i class="fa fa-check"></i><b>6.3</b> Facets</a></li>
<li class="chapter" data-level="6.4" data-path="data-visualization.html"><a href="data-visualization.html#saving"><i class="fa fa-check"></i><b>6.4</b> Saving</a></li>
<li class="chapter" data-level="6.5" data-path="data-visualization.html"><a href="data-visualization.html#exercises-3"><i class="fa fa-check"></i><b>6.5</b> Exercises</a></li>
<li class="chapter" data-level="6.6" data-path="data-visualization.html"><a href="data-visualization.html#resources-and-links"><i class="fa fa-check"></i><b>6.6</b> Resources and Links</a></li>
</ul></li>
<li class="part"><span><b>IV Appendix</b></span></li>
<li class="chapter" data-level="7" data-path="appendix-resources.html"><a href="appendix-resources.html"><i class="fa fa-check"></i><b>7</b> Appendix A</a><ul>
<li class="chapter" data-level="7.1" data-path="appendix-resources.html"><a href="appendix-resources.html#e-books"><i class="fa fa-check"></i><b>7.1</b> E-Books</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Modern R in a Corporate Environment</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="subsetting" class="section level1">
<h1><span class="header-section-number">5</span> Subsetting</h1>
<p>R’s subsetting operators are powerful and fast. Mastery of subsetting allows you to succinctly express complex operations in a way that few other languages can match. Subsetting can be hard to learn because you need to master a number of interrelated concepts:</p>
<ul>
<li>The three subsetting operators</li>
<li><code>[</code> select multiple elements</li>
<li><p><code>[[</code>, and <code>$</code> select a single element</p></li>
<li>The six types of subsetting.
<ul>
<li><strong>Positive integers</strong> return elements at the specified positions</li>
<li><strong>Negative integers</strong> omit elements at the specified positions</li>
<li><strong>Logical vectors</strong> select elements where the corresponding logical value is <code>TRUE</code></li>
<li><strong>Nothing</strong> returns the original object.</li>
<li><strong>Zero</strong> returns a zero-length object (This is not something you usually do on purpose)</li>
<li><strong>Character vectors</strong> to return elements with matching names.</li>
</ul></li>
<li><p>Important differences in behavior for different objects (e.g., vectors, lists, factors, matrices, and data frames).</p></li>
<li><p>The use of subsetting in conjunction with assignment.</p></li>
</ul>
<p>It’s easiest to learn how subsetting works for atomic vectors, and then how it generalizes to higher dimensions and other more complicated objects.</p>
<div id="selecting-multiple-elements" class="section level2">
<h2><span class="header-section-number">5.1</span> Selecting multiple elements</h2>
<p>There is one accessor for selecting multiple elements <code>[</code>.</p>
<div id="atomic-vectors-1" class="section level3">
<h3><span class="header-section-number">5.1.1</span> Atomic vectors</h3>
<p>Let’s explore the different types of subsetting with a simple vector, <code>x</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">2.1</span>, <span class="fl">4.2</span>, <span class="fl">3.3</span>, <span class="fl">5.4</span>)</code></pre></div>
<p>Note that the number after the decimal point gives the original position in the vector.</p>
<p>There are five things that you can use to subset a vector.</p>
<ul>
<li><strong>Positive integers</strong> return elements at the specified positions</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">1</span>)]
<span class="co">#&gt; [1] 3.3 2.1</span>

<span class="co"># order returns an index</span>
x[<span class="kw">order</span>(x)]
<span class="co">#&gt; [1] 2.1 3.3 4.2 5.4</span>

<span class="co"># Duplicated indices yield duplicated values</span>
x[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>)]
<span class="co">#&gt; [1] 2.1 2.1</span>

<span class="co"># Real numbers are silently truncated (not rounded) to integers</span>
x[<span class="kw">c</span>(<span class="fl">2.1</span>, <span class="fl">2.9</span>)]
<span class="co">#&gt; [1] 4.2 4.2</span></code></pre></div>
<ul>
<li><strong>Negative integers</strong> omit elements at the specified positions</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="op">-</span><span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">1</span>)]
<span class="co">#&gt; [1] 4.2 5.4</span></code></pre></div>
<p>You can’t mix positive and negative integers in a single subset.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">2</span>)]
<span class="co">#&gt; Error in x[c(-1, 2)]: only 0&#39;s may be mixed with negative subscripts</span></code></pre></div>
<ul>
<li><strong>Logical vectors</strong> select elements where the corresponding logical value is <code>TRUE</code>. This is probably the most useful type of subsetting because you write the expression that creates the logical vector:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">FALSE</span>)]
<span class="co">#&gt; [1] 2.1 4.2</span>
x[x <span class="op">&gt;</span><span class="st"> </span><span class="dv">3</span>]
<span class="co">#&gt; [1] 4.2 3.3 5.4</span></code></pre></div>
<p>If the logical vector is shorter than the vector being subsetted, it will be <em>recycled</em> to be the same length.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)]
<span class="co">#&gt; [1] 2.1 3.3</span>
<span class="co"># Equivalent to</span>
x[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>)]
<span class="co">#&gt; [1] 2.1 3.3</span></code></pre></div>
<p>A missing value in the index always yields a missing value in the output.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">TRUE</span>, <span class="ot">NA</span>, <span class="ot">FALSE</span>)]
<span class="co">#&gt; [1] 2.1 4.2  NA</span></code></pre></div>
<ul>
<li><strong>Nothing</strong> returns the original vector. This is not useful for vectors but is very useful for matrices, data frames, and arrays. It can also be useful in conjunction with assignment.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[]
<span class="co">#&gt; [1] 2.1 4.2 3.3 5.4</span></code></pre></div>
<ul>
<li><strong>Zero</strong> returns a zero-length vector. This is not something you usually do on purpose, but it can be helpful for generating test data and testing corner cases of functions.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="dv">0</span>]
<span class="co">#&gt; numeric(0)</span></code></pre></div>
<p>If the vector is named, you can also use:</p>
<ul>
<li><strong>Character vectors</strong> to return elements with matching names.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(y &lt;-<span class="st"> </span><span class="kw">setNames</span>(x, letters[<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>]))
<span class="co">#&gt;   a   b   c   d </span>
<span class="co">#&gt; 2.1 4.2 3.3 5.4</span>
<span class="co"># subsetting by name</span>
y[<span class="kw">c</span>(<span class="st">&quot;d&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;a&quot;</span>)]
<span class="co">#&gt;   d   c   a </span>
<span class="co">#&gt; 5.4 3.3 2.1</span>

<span class="co"># Like integer indices, you can repeat indices</span>
y[<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;a&quot;</span>)]
<span class="co">#&gt;   a   a   a </span>
<span class="co">#&gt; 2.1 2.1 2.1</span>

<span class="co"># When subsetting with [ names are always matched exactly</span>
z &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">abc =</span> <span class="dv">1</span>, <span class="dt">def =</span> <span class="dv">2</span>)
z[<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;d&quot;</span>)]
<span class="co">#&gt; &lt;NA&gt; &lt;NA&gt; </span>
<span class="co">#&gt;   NA   NA</span></code></pre></div>
</div>
<div id="matrices-and-arrays-1" class="section level3">
<h3><span class="header-section-number">5.1.2</span> Matrices and Arrays</h3>
<p>You can subset higher-dimensional structures in three ways:</p>
<ul>
<li>With multiple vectors.</li>
<li>With a single vector.</li>
<li>With a matrix.</li>
</ul>
<p>The most common way of subsetting matrices (2d) and arrays (&gt;2d) is a simple generalization of 1d subsetting: you supply a 1d index for each dimension, separated by a comma. Blank subsetting is now useful because it lets you keep all rows or all columns.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">9</span>, <span class="dt">nrow =</span> <span class="dv">3</span>)
<span class="kw">colnames</span>(a) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="st">&quot;C&quot;</span>)
a[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, ]
<span class="co">#&gt;      A B C</span>
<span class="co">#&gt; [1,] 1 4 7</span>
<span class="co">#&gt; [2,] 2 5 8</span>
a[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>), <span class="kw">c</span>(<span class="st">&quot;B&quot;</span>, <span class="st">&quot;A&quot;</span>)]
<span class="co">#&gt;      B A</span>
<span class="co">#&gt; [1,] 4 1</span>
<span class="co">#&gt; [2,] 6 3</span>
a[<span class="dv">2</span><span class="op">:</span><span class="dv">3</span>, <span class="op">-</span><span class="dv">2</span>]
<span class="co">#&gt;      A C</span>
<span class="co">#&gt; [1,] 2 8</span>
<span class="co">#&gt; [2,] 3 9</span></code></pre></div>
<p>By default, <code>[</code> will simplify the results to the lowest possible dimensionality. See below how to avoid this behavior.</p>
<p>Because matrices and arrays are implemented as vectors with special attributes, you can subset them with a single vector. In that case, they will behave like a vector. Arrays in R are stored in column-major order:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(vals &lt;-<span class="st"> </span><span class="kw">outer</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dt">FUN =</span> <span class="st">&quot;paste&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;,&quot;</span>))
<span class="co">#&gt;      [,1]  [,2]  [,3]  [,4]  [,5] </span>
<span class="co">#&gt; [1,] &quot;1,1&quot; &quot;1,2&quot; &quot;1,3&quot; &quot;1,4&quot; &quot;1,5&quot;</span>
<span class="co">#&gt; [2,] &quot;2,1&quot; &quot;2,2&quot; &quot;2,3&quot; &quot;2,4&quot; &quot;2,5&quot;</span>
<span class="co">#&gt; [3,] &quot;3,1&quot; &quot;3,2&quot; &quot;3,3&quot; &quot;3,4&quot; &quot;3,5&quot;</span>
<span class="co">#&gt; [4,] &quot;4,1&quot; &quot;4,2&quot; &quot;4,3&quot; &quot;4,4&quot; &quot;4,5&quot;</span>
<span class="co">#&gt; [5,] &quot;5,1&quot; &quot;5,2&quot; &quot;5,3&quot; &quot;5,4&quot; &quot;5,5&quot;</span>
vals[<span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">15</span>)]
<span class="co">#&gt; [1] &quot;4,1&quot; &quot;5,3&quot;</span></code></pre></div>
<p>This behavior allows you to replace all missing values in one line.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># make a few values missing</span>
vals[<span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">25</span>, <span class="dv">5</span>)] &lt;-<span class="st"> </span><span class="ot">NA_character_</span>
vals
<span class="co">#&gt;      [,1]  [,2]  [,3]  [,4]  [,5] </span>
<span class="co">#&gt; [1,] &quot;1,1&quot; &quot;1,2&quot; NA    &quot;1,4&quot; &quot;1,5&quot;</span>
<span class="co">#&gt; [2,] NA    &quot;2,2&quot; &quot;2,3&quot; &quot;2,4&quot; &quot;2,5&quot;</span>
<span class="co">#&gt; [3,] &quot;3,1&quot; &quot;3,2&quot; &quot;3,3&quot; &quot;3,4&quot; &quot;3,5&quot;</span>
<span class="co">#&gt; [4,] NA    NA    &quot;4,3&quot; &quot;4,4&quot; NA   </span>
<span class="co">#&gt; [5,] &quot;5,1&quot; &quot;5,2&quot; &quot;5,3&quot; &quot;5,4&quot; &quot;5,5&quot;</span>
<span class="co"># replace missing values with &quot;missing&quot;</span>
vals[<span class="kw">is.na</span>(vals)] &lt;-<span class="st"> &quot;missing&quot;</span>
vals
<span class="co">#&gt;      [,1]      [,2]      [,3]      [,4]  [,5]     </span>
<span class="co">#&gt; [1,] &quot;1,1&quot;     &quot;1,2&quot;     &quot;missing&quot; &quot;1,4&quot; &quot;1,5&quot;    </span>
<span class="co">#&gt; [2,] &quot;missing&quot; &quot;2,2&quot;     &quot;2,3&quot;     &quot;2,4&quot; &quot;2,5&quot;    </span>
<span class="co">#&gt; [3,] &quot;3,1&quot;     &quot;3,2&quot;     &quot;3,3&quot;     &quot;3,4&quot; &quot;3,5&quot;    </span>
<span class="co">#&gt; [4,] &quot;missing&quot; &quot;missing&quot; &quot;4,3&quot;     &quot;4,4&quot; &quot;missing&quot;</span>
<span class="co">#&gt; [5,] &quot;5,1&quot;     &quot;5,2&quot;     &quot;5,3&quot;     &quot;5,4&quot; &quot;5,5&quot;</span></code></pre></div>
<p>You can also subset higher-dimensional data structures with an integer matrix (or, if named, a character matrix). Each row in the matrix specifies the location of one value, where each column corresponds to a dimension in the array being subsetted. This means that you use a 2 column matrix to subset a matrix, a 3 column matrix to subset a 3d array, and so on. The result is a vector of values:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">vals &lt;-<span class="st"> </span><span class="kw">outer</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dt">FUN =</span> <span class="st">&quot;paste&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;,&quot;</span>)
select &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dt">ncol =</span> <span class="dv">2</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>, <span class="kw">c</span>(
  <span class="dv">1</span>, <span class="dv">1</span>,
  <span class="dv">3</span>, <span class="dv">1</span>,
  <span class="dv">2</span>, <span class="dv">4</span>
))
vals[select]
<span class="co">#&gt; [1] &quot;1,1&quot; &quot;3,1&quot; &quot;2,4&quot;</span></code></pre></div>
</div>
<div id="lists-1" class="section level3">
<h3><span class="header-section-number">5.1.3</span> Lists</h3>
<p>Subsetting a list works in the same way as subsetting an atomic vector. Using <code>[</code> will always return a list; <code>[[</code> and <code>$</code>, as described below, let you pull out the components of the list.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="st">&quot;a&quot;</span>, <span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>), <span class="kw">c</span>(<span class="fl">2.3</span>, <span class="fl">5.9</span>))
x
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] 1 2 3</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] &quot;a&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; [1]  TRUE FALSE  TRUE</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[4]]</span>
<span class="co">#&gt; [1] 2.3 5.9</span>
x[<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">4</span>)]
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] 1 2 3</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] 2.3 5.9</span></code></pre></div>
</div>
<div id="data-frames-1" class="section level3">
<h3><span class="header-section-number">5.1.4</span> Data Frames</h3>
<p>Data frames possess the characteristics of both lists and matrices: if you subset with a single vector, they behave like lists; if you subset with two vectors, they behave like matrices.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">y =</span> <span class="dv">3</span><span class="op">:</span><span class="dv">1</span>, <span class="dt">z =</span> letters[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])
df
<span class="co">#&gt;   x y z</span>
<span class="co">#&gt; 1 1 3 a</span>
<span class="co">#&gt; 2 2 2 b</span>
<span class="co">#&gt; 3 3 1 c</span>

<span class="co"># There are two ways to select columns from a data frame</span>
<span class="co"># Like a list:</span>
df[<span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;z&quot;</span>)]
<span class="co">#&gt;   x z</span>
<span class="co">#&gt; 1 1 a</span>
<span class="co">#&gt; 2 2 b</span>
<span class="co">#&gt; 3 3 c</span>
<span class="co"># Like a matrix</span>
df[, <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;z&quot;</span>)]
<span class="co">#&gt;   x z</span>
<span class="co">#&gt; 1 1 a</span>
<span class="co">#&gt; 2 2 b</span>
<span class="co">#&gt; 3 3 c</span>

<span class="co"># There&#39;s an important difference if you select a single </span>
<span class="co"># column: matrix subsetting simplifies by default, list </span>
<span class="co"># subsetting does not.</span>
<span class="kw">str</span>(df[<span class="st">&quot;x&quot;</span>])
<span class="co">#&gt; &#39;data.frame&#39;:    3 obs. of  1 variable:</span>
<span class="co">#&gt;  $ x: int  1 2 3</span>
<span class="kw">str</span>(df[, <span class="st">&quot;x&quot;</span>])
<span class="co">#&gt;  int [1:3] 1 2 3</span>

<span class="co"># for row subset like a matrix</span>
df[df<span class="op">$</span>x <span class="op">==</span><span class="st"> </span><span class="dv">2</span>, ]
<span class="co">#&gt;   x y z</span>
<span class="co">#&gt; 2 2 2 b</span>
df[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>), ]
<span class="co">#&gt;   x y z</span>
<span class="co">#&gt; 1 1 3 a</span>
<span class="co">#&gt; 3 3 1 c</span></code></pre></div>
</div>
<div id="preserving-dimensionality" class="section level3">
<h3><span class="header-section-number">5.1.5</span> Preserving dimensionality</h3>
<p>By default, any subsetting 2d data structures with a single number, single name, or a logical vector containing a single <code>TRUE</code> will simplify the returned output as described below. To preserve the original dimensionality, you must use <code>drop = FALSE</code></p>
<ul>
<li><p>For matrices and arrays, any dimensions with length 1 will be dropped:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(a &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dt">nrow =</span> <span class="dv">2</span>))
<span class="co">#&gt;      [,1] [,2]</span>
<span class="co">#&gt; [1,]    1    3</span>
<span class="co">#&gt; [2,]    2    4</span>
<span class="kw">str</span>(a[<span class="dv">1</span>, ])
<span class="co">#&gt;  int [1:2] 1 3</span>

<span class="kw">str</span>(a[<span class="dv">1</span>, , <span class="dt">drop =</span> <span class="ot">FALSE</span>])
<span class="co">#&gt;  int [1, 1:2] 1 3</span></code></pre></div></li>
<li><p>Data frames with a single column will return just that column:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">a =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, <span class="dt">b =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>))
<span class="co">#&gt;   a b</span>
<span class="co">#&gt; 1 1 1</span>
<span class="co">#&gt; 2 2 2</span>
<span class="kw">str</span>(df[, <span class="st">&quot;a&quot;</span>])
<span class="co">#&gt;  int [1:2] 1 2</span>

<span class="kw">str</span>(df[, <span class="st">&quot;a&quot;</span>, <span class="dt">drop =</span> <span class="ot">FALSE</span>])
<span class="co">#&gt; &#39;data.frame&#39;:    2 obs. of  1 variable:</span>
<span class="co">#&gt;  $ a: int  1 2</span></code></pre></div></li>
</ul>
<p>The default <code>drop = TRUE</code> behavior is a common source of bugs in functions: you check your code with a data frame or matrix with multiple columns, and it works. Six months later you (or someone else) uses it with a single column data frame and it fails with a mystifying error. When writing functions, get in the habit of always using <code>drop = FALSE</code> when subsetting a 2d object.</p>
<p>Factor subsetting also has a <code>drop</code> argument, but the meaning it rather different. It controls whether or not levels are preserved (not the dimensionality), and it defaults to <code>FALSE</code> (levels are preserved, not simplified by default). If you find you are using <code>drop = TRUE</code> a lot it’s often a sign that you should be using a character vector instead of a factor.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">z &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>))
z[<span class="dv">1</span>]
<span class="co">#&gt; [1] a</span>
<span class="co">#&gt; Levels: a b</span>
z[<span class="dv">1</span>, drop =<span class="st"> </span><span class="ot">TRUE</span>]
<span class="co">#&gt; [1] a</span>
<span class="co">#&gt; Levels: a</span></code></pre></div>
</div>
</div>
<div id="selecting-a-single-elements" class="section level2">
<h2><span class="header-section-number">5.2</span> Selecting a single elements</h2>
<p>There are two other subsetting operators: <code>[[</code> and <code>$</code>. <code>[[</code> is used for extracting single values, and <code>$</code> is a useful shorthand for <code>[[</code> combined with character subsetting. <code>[[</code> is most important working with lists because subsetting a list with <code>[</code> always returns a smaller list. To help make this easier to understand we can use a metaphor:</p>
<blockquote>
<p>“If list <code>x</code> is a train carrying objects, then <code>x[[5]]</code> is the object in car 5; <code>x[4:6]</code> is a train of cars 4-6.”</p>
<p>— @RLangTip, <a href="https://twitter.com/RLangTip/status/268375867468681216" class="uri">https://twitter.com/RLangTip/status/268375867468681216</a></p>
</blockquote>
<p>Let’s make a simple list and draw it as a train:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="st">&quot;a&quot;</span>, <span class="dv">4</span><span class="op">:</span><span class="dv">6</span>)</code></pre></div>
<p><img src="images/subsetting/train.png" width="340" style="display: block; margin: auto;" /></p>
<p>When extracting a single element, you have two options: you can create a smaller train, or you can extract the contents of a carriage. This is the difference between <code>[</code> and <code>[[</code>:</p>
<p><img src="images/subsetting/train-single.png" width="264" style="display: block; margin: auto;" /></p>
<p>When extracting multiple elements (or zero!), you have to make a smaller train:</p>
<p><img src="images/subsetting/train-multiple.png" width="359" style="display: block; margin: auto;" /></p>
<p>Because it can return only a single value, you must use <code>[[</code> with either a single positive integer or a string. Because data frames are lists of columns, you can use <code>[[</code> to extract a column from data frames: <code>mtcars[[1]]</code>, <code>mtcars[[&quot;cyl&quot;]]</code>.</p>
<p>If you use a vector with <code>[[</code>, it will subset recursively:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(b &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="kw">list</span>(<span class="dt">b =</span> <span class="kw">list</span>(<span class="dt">c =</span> <span class="kw">list</span>(<span class="dt">d =</span> <span class="dv">1</span>)))))
<span class="co">#&gt; $a</span>
<span class="co">#&gt; $a$b</span>
<span class="co">#&gt; $a$b$c</span>
<span class="co">#&gt; $a$b$c$d</span>
<span class="co">#&gt; [1] 1</span>
<span class="kw">str</span>(b)
<span class="co">#&gt; List of 1</span>
<span class="co">#&gt;  $ a:List of 1</span>
<span class="co">#&gt;   ..$ b:List of 1</span>
<span class="co">#&gt;   .. ..$ c:List of 1</span>
<span class="co">#&gt;   .. .. ..$ d: num 1</span>
b[[<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;d&quot;</span>)]]
<span class="co">#&gt; [1] 1</span>

<span class="co"># Equivalent to</span>
b[[<span class="st">&quot;a&quot;</span>]][[<span class="st">&quot;b&quot;</span>]][[<span class="st">&quot;c&quot;</span>]][[<span class="st">&quot;d&quot;</span>]]
<span class="co">#&gt; [1] 1</span></code></pre></div>
<p><code>[[</code> is crucial for working with lists, but I recommend using it whenever you want your code to clearly express that it’s working with a single value. That frequently arises in for loops, i.e. instead of writing:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="kw">length</span>(x)) {
  out[i] &lt;-<span class="st"> </span><span class="kw">fun</span>(x[i], out[i <span class="op">-</span><span class="st"> </span><span class="dv">1</span>])
}</code></pre></div>
<p>It’s better to write:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="kw">length</span>(x)) {
  out[[i]] &lt;-<span class="st"> </span><span class="kw">fun</span>(x[[i]], out[[i <span class="op">-</span><span class="st"> </span><span class="dv">1</span>]])
}</code></pre></div>
<div id="section" class="section level3">
<h3><span class="header-section-number">5.2.1</span> <code>$</code></h3>
<p><code>$</code> is a shorthand operator: <code>x$y</code> is roughly equivalent to <code>x[[&quot;y&quot;]]</code>. It’s often used to access variables in a data frame, as in <code>mtcars$cyl</code> or <code>diamonds$carat</code>. One common mistake with <code>$</code> is to try and use it when you have the name of a column stored in a variable:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var &lt;-<span class="st"> &quot;cyl&quot;</span>
<span class="co"># Doesn&#39;t work - mtcars$var translated to mtcars[[&quot;var&quot;]]</span>
mtcars<span class="op">$</span>var
<span class="co">#&gt; NULL</span>

<span class="co"># Instead use [[</span>
mtcars[[var]]
<span class="co">#&gt;  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4</span></code></pre></div>
<p>There’s one important difference between <code>$</code> and <code>[[</code>. <code>$</code> does partial matching:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">abc =</span> <span class="dv">1</span>, <span class="dt">def =</span> <span class="dv">2</span>, <span class="dt">ghi =</span> <span class="kw">c</span>(<span class="dv">4</span><span class="op">:</span><span class="dv">6</span>))
x<span class="op">$</span>d
<span class="co">#&gt; [1] 2</span>
x[[<span class="st">&quot;d&quot;</span>]]
<span class="co">#&gt; NULL</span>
x[[<span class="st">&quot;def&quot;</span>]]
<span class="co">#&gt; [1] 2</span></code></pre></div>
<p>It is usually a good idea to <strong>NOT</strong> use partial matching. It tends to to lead to hard to track down bugs and makes your code much less readable. With auto complete in RStudio it tends not to save any time or keystrokes.</p>
</div>
<div id="missingout-of-bounds-indices" class="section level3">
<h3><span class="header-section-number">5.2.2</span> Missing/out of bounds indices</h3>
<p>TL;DR version use <code>purrr::pluck()</code>, which we will get to in <em>R for Data Science</em></p>
<p>It’s useful to understand what happens with <code>[</code> and <code>[[</code> when you use an “invalid” index. The following tables summarize what happen when you subset a logical vector, list, and <code>NULL</code> with an out-of-bounds value (OOB), a missing value (i.e <code>NA_integer_</code>), and a zero-length object (like <code>NULL</code> or <code>logical()</code>) with <code>[</code> and <code>[[</code>. Each cell shows the result of subsetting the data structure named in the row by the type of index described in the column. I’ve only shown the results for logical vectors, but other atomic vectors behave similarly, returning elements of the same type.</p>
<table>
<thead>
<tr class="header">
<th><code>row[col]</code></th>
<th>Zero-length</th>
<th>OOB</th>
<th>Missing</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Logical</td>
<td><code>logical(0)</code></td>
<td><code>NA</code></td>
<td><code>NA</code></td>
</tr>
<tr class="even">
<td>List</td>
<td><code>list()</code></td>
<td><code>list(NULL)</code></td>
<td><code>list(NULL)</code></td>
</tr>
<tr class="odd">
<td><code>NULL</code></td>
<td><code>NULL</code></td>
<td><code>NULL</code></td>
<td><code>NULL</code></td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>)
x[<span class="ot">NULL</span>]
<span class="co">#&gt; logical(0)</span>
x[<span class="dv">10</span>]
<span class="co">#&gt; [1] NA</span>
x[<span class="ot">NA_real_</span>]
<span class="co">#&gt; [1] NA</span>

y &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">abc =</span> <span class="dv">1</span>, <span class="dt">def =</span> <span class="dv">2</span>, <span class="dt">ghi =</span> <span class="kw">c</span>(<span class="dv">4</span><span class="op">:</span><span class="dv">6</span>))
y[<span class="ot">NULL</span>]
<span class="co">#&gt; named list()</span>
y[<span class="dv">10</span>]
<span class="co">#&gt; $&lt;NA&gt;</span>
<span class="co">#&gt; NULL</span>
y[<span class="ot">NA_real_</span>]
<span class="co">#&gt; $&lt;NA&gt;</span>
<span class="co">#&gt; NULL</span>

<span class="ot">NULL</span>[<span class="ot">NULL</span>]
<span class="co">#&gt; NULL</span>
<span class="ot">NULL</span>[<span class="dv">1</span>]
<span class="co">#&gt; NULL</span>
<span class="ot">NULL</span>[<span class="ot">NA_real_</span>]
<span class="co">#&gt; NULL</span></code></pre></div>
<p>With <code>[</code>, it doesn’t matter whether the OOB index is a position or a name, but it does for <code>[[</code>:</p>
<table>
<thead>
<tr class="header">
<th><code>row[[col]]</code></th>
<th>Zero-length</th>
<th>OOB (int)</th>
<th>OOB (chr)</th>
<th>Missing</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Atomic</td>
<td>Error</td>
<td>Error</td>
<td>Error</td>
<td>Error</td>
</tr>
<tr class="even">
<td>List</td>
<td>Error</td>
<td>Error</td>
<td><code>NULL</code></td>
<td><code>NULL</code></td>
</tr>
<tr class="odd">
<td><code>NULL</code></td>
<td><code>NULL</code></td>
<td><code>NULL</code></td>
<td><code>NULL</code></td>
<td><code>NULL</code></td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x
<span class="co">#&gt; [1]  TRUE FALSE  TRUE</span>
x[[<span class="ot">NULL</span>]]
<span class="co">#&gt; Error in x[[NULL]]: attempt to select less than one element in get1index</span>
x[[<span class="dv">10</span>]]
<span class="co">#&gt; Error in x[[10]]: subscript out of bounds</span>
x[[<span class="st">&quot;x&quot;</span>]]
<span class="co">#&gt; Error in x[[&quot;x&quot;]]: subscript out of bounds</span>
x[[<span class="ot">NA_real_</span>]]
<span class="co">#&gt; Error in x[[NA_real_]]: subscript out of bounds</span>

y
<span class="co">#&gt; $abc</span>
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $def</span>
<span class="co">#&gt; [1] 2</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $ghi</span>
<span class="co">#&gt; [1] 4 5 6</span>
y[[<span class="ot">NULL</span>]]
<span class="co">#&gt; Error in y[[NULL]]: attempt to select less than one element in get1index</span>
y[[<span class="dv">10</span>]]
<span class="co">#&gt; Error in y[[10]]: subscript out of bounds</span>
y[[<span class="st">&quot;x&quot;</span>]]
<span class="co">#&gt; NULL</span>
y[[<span class="ot">NA_real_</span>]]
<span class="co">#&gt; NULL</span>

<span class="ot">NULL</span>[[<span class="ot">NULL</span>]]
<span class="co">#&gt; NULL</span>
<span class="ot">NULL</span>[[<span class="dv">1</span>]]
<span class="co">#&gt; NULL</span>
<span class="ot">NULL</span>[[<span class="st">&quot;x&quot;</span>]]
<span class="co">#&gt; NULL</span>
<span class="ot">NULL</span>[[<span class="ot">NA_real_</span>]]
<span class="co">#&gt; NULL</span></code></pre></div>
<p>If the input vector is named, then the names of OOB, missing, or <code>NULL</code> components will be <code>&quot;&lt;NA&gt;&quot;</code>.</p>
</div>
</div>
<div id="subassignment" class="section level2">
<h2><span class="header-section-number">5.3</span> Subsetting and assignment</h2>
<p>All subsetting operators can be combined with assignment to modify selected values of the input vector.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">5</span>
x[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>)] &lt;-<span class="st"> </span><span class="dv">2</span><span class="op">:</span><span class="dv">3</span>
x
<span class="co">#&gt; [1] 2 3 3 4 5</span>

<span class="co"># The length of the LHS needs to match the RHS</span>
x[<span class="op">-</span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">4</span><span class="op">:</span><span class="dv">1</span>
x
<span class="co">#&gt; [1] 2 4 3 2 1</span>

<span class="co"># Duplicated indices go unchecked and may be problematic</span>
x[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>)] &lt;-<span class="st"> </span><span class="dv">2</span><span class="op">:</span><span class="dv">3</span>
x
<span class="co">#&gt; [1] 3 4 3 2 1</span>

<span class="co"># You can&#39;t combine integer indices with NA</span>
x[<span class="kw">c</span>(<span class="dv">1</span>, <span class="ot">NA</span>)] &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>)
<span class="co">#&gt; Error in x[c(1, NA)] &lt;- c(1, 2): NAs are not allowed in subscripted assignments</span>
<span class="co"># But you can combine logical indices with NA</span>
<span class="co"># (where they are treated as FALSE).</span>
x[<span class="kw">c</span>(T, F, <span class="ot">NA</span>)] &lt;-<span class="st"> </span><span class="dv">1</span>
x
<span class="co">#&gt; [1] 1 4 3 1 1</span>

<span class="co"># This is mostly useful when conditionally modifying vectors</span>
df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">a =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">10</span>, <span class="ot">NA</span>))
df<span class="op">$</span>a[df<span class="op">$</span>a <span class="op">&lt;</span><span class="st"> </span><span class="dv">5</span>] &lt;-<span class="st"> </span><span class="dv">0</span>
df<span class="op">$</span>a
<span class="co">#&gt; [1]  0 10 NA</span></code></pre></div>
<p>Subsetting with nothing can be useful in conjunction with assignment because it will preserve the original object class and structure. Compare the following two expressions. In the first, <code>mtcars</code> will remain as a data frame. In the second, <code>mtcars</code> will become a list.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mtcars[] &lt;-<span class="st"> </span><span class="kw">lapply</span>(mtcars, as.integer)
mtcars &lt;-<span class="st"> </span><span class="kw">lapply</span>(mtcars, as.integer)</code></pre></div>
<p>With lists, you can use <code>[[</code> + assignment + <code>NULL</code> to remove components from a list. To add a literal <code>NULL</code> to a list, use <code>[</code> and <code>list(NULL)</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>)
x[[<span class="st">&quot;b&quot;</span>]] &lt;-<span class="st"> </span><span class="ot">NULL</span>
<span class="kw">str</span>(x)
<span class="co">#&gt; List of 1</span>
<span class="co">#&gt;  $ a: num 1</span>

y &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="dv">1</span>)
y[<span class="st">&quot;b&quot;</span>] &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="ot">NULL</span>)
<span class="kw">str</span>(y)
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ a: num 1</span>
<span class="co">#&gt;  $ b: NULL</span></code></pre></div>
</div>
<div id="applications" class="section level2">
<h2><span class="header-section-number">5.4</span> Applications</h2>
<p>The basic principles described above give rise to a wide variety of useful applications. Some of the most important are described below. Many of these basic techniques are wrapped up into more concise functions (e.g., <code>subset()</code>, <code>merge()</code>, <code>dplyr::arrange()</code>), but it is useful to understand how they are implemented with basic subsetting. This will allow you to adapt to new situations that are not dealt with by existing functions.</p>
<div id="lookup-tables-character-subsetting" class="section level3">
<h3><span class="header-section-number">5.4.1</span> Lookup tables (character subsetting)</h3>
<p>Character matching provides a powerful way to make look-up tables. Say you want to convert abbreviations:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;m&quot;</span>, <span class="st">&quot;f&quot;</span>, <span class="st">&quot;u&quot;</span>, <span class="st">&quot;f&quot;</span>, <span class="st">&quot;f&quot;</span>, <span class="st">&quot;m&quot;</span>, <span class="st">&quot;m&quot;</span>)
lookup &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">m =</span> <span class="st">&quot;Male&quot;</span>, <span class="dt">f =</span> <span class="st">&quot;Female&quot;</span>, <span class="dt">u =</span> <span class="ot">NA</span>)
lookup[x]
<span class="co">#&gt;        m        f        u        f        f        m        m </span>
<span class="co">#&gt;   &quot;Male&quot; &quot;Female&quot;       NA &quot;Female&quot; &quot;Female&quot;   &quot;Male&quot;   &quot;Male&quot;</span>

<span class="kw">unname</span>(lookup[x])
<span class="co">#&gt; [1] &quot;Male&quot;   &quot;Female&quot; NA       &quot;Female&quot; &quot;Female&quot; &quot;Male&quot;   &quot;Male&quot;</span></code></pre></div>
<p>If you don’t want names in the result, use <code>unname()</code> to remove them.</p>
</div>
<div id="ordering-integer-subsetting" class="section level3">
<h3><span class="header-section-number">5.4.2</span> Ordering (integer subsetting)</h3>
<p><code>order()</code> takes a vector as input and returns an integer vector describing how the subsetted vector should be ordered:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;a&quot;</span>)
<span class="kw">order</span>(x)
<span class="co">#&gt; [1] 3 1 2</span>
x[<span class="kw">order</span>(x)]
<span class="co">#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</span></code></pre></div>
<p>To break ties, you can supply additional variables to <code>order()</code>, and you can change from ascending to descending order using <code>decreasing = TRUE</code>. By default, any missing values will be put at the end of the vector; however, you can remove them with <code>na.last = NA</code> or put at the front with <code>na.last = FALSE</code>.</p>
<p>For two or more dimensions, <code>order()</code> and integer subsetting makes it easy to order either the rows or columns of an object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">each =</span> <span class="dv">2</span>), <span class="dt">y =</span> <span class="dv">6</span><span class="op">:</span><span class="dv">1</span>, <span class="dt">z =</span> letters[<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>]))
<span class="co">#&gt;   x y z</span>
<span class="co">#&gt; 1 1 6 a</span>
<span class="co">#&gt; 2 1 5 b</span>
<span class="co">#&gt; 3 2 4 c</span>
<span class="co">#&gt; 4 2 3 d</span>
<span class="co">#&gt; 5 3 2 e</span>
<span class="co">#&gt; 6 3 1 f</span>
<span class="co"># Randomly reorder df</span>
df2 &lt;-<span class="st"> </span>df[<span class="kw">sample</span>(<span class="kw">nrow</span>(df)), <span class="dv">3</span><span class="op">:</span><span class="dv">1</span>]
df2
<span class="co">#&gt;   z y x</span>
<span class="co">#&gt; 3 c 4 2</span>
<span class="co">#&gt; 2 b 5 1</span>
<span class="co">#&gt; 5 e 2 3</span>
<span class="co">#&gt; 6 f 1 3</span>
<span class="co">#&gt; 4 d 3 2</span>
<span class="co">#&gt; 1 a 6 1</span>

df2[<span class="kw">order</span>(df2<span class="op">$</span>x), ]
<span class="co">#&gt;   z y x</span>
<span class="co">#&gt; 2 b 5 1</span>
<span class="co">#&gt; 1 a 6 1</span>
<span class="co">#&gt; 3 c 4 2</span>
<span class="co">#&gt; 4 d 3 2</span>
<span class="co">#&gt; 5 e 2 3</span>
<span class="co">#&gt; 6 f 1 3</span>
df2[, <span class="kw">order</span>(<span class="kw">names</span>(df2))]
<span class="co">#&gt;   x y z</span>
<span class="co">#&gt; 3 2 4 c</span>
<span class="co">#&gt; 2 1 5 b</span>
<span class="co">#&gt; 5 3 2 e</span>
<span class="co">#&gt; 6 3 1 f</span>
<span class="co">#&gt; 4 2 3 d</span>
<span class="co">#&gt; 1 1 6 a</span></code></pre></div>
<p>You can sort vectors directly with <code>sort()</code>, or use <code>dplyr::arrange()</code> or similar to sort a data frame.</p>
</div>
<div id="selecting-rows-based-on-a-condition-logical-subsetting" class="section level3">
<h3><span class="header-section-number">5.4.3</span> Selecting rows based on a condition (logical subsetting)</h3>
<p>Because it allows you to easily combine conditions from multiple columns, logical subsetting is probably the most commonly used technique for extracting rows out of a data frame.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mtcars[mtcars<span class="op">$</span>gear <span class="op">==</span><span class="st"> </span><span class="dv">5</span>, ]
<span class="co">#&gt;                 mpg cyl  disp  hp drat   wt qsec vs am gear carb</span>
<span class="co">#&gt; Porsche 914-2  26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2</span>
<span class="co">#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2</span>
<span class="co">#&gt; Ford Pantera L 15.8   8 351.0 264 4.22 3.17 14.5  0  1    5    4</span>
<span class="co">#&gt; Ferrari Dino   19.7   6 145.0 175 3.62 2.77 15.5  0  1    5    6</span>
<span class="co">#&gt; Maserati Bora  15.0   8 301.0 335 3.54 3.57 14.6  0  1    5    8</span>

mtcars[mtcars<span class="op">$</span>gear <span class="op">==</span><span class="st"> </span><span class="dv">5</span> <span class="op">&amp;</span><span class="st"> </span>mtcars<span class="op">$</span>cyl <span class="op">==</span><span class="st"> </span><span class="dv">4</span>, ]
<span class="co">#&gt;                mpg cyl  disp  hp drat   wt qsec vs am gear carb</span>
<span class="co">#&gt; Porsche 914-2 26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2</span>
<span class="co">#&gt; Lotus Europa  30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2</span></code></pre></div>
<p>Remember to use the vector boolean operators <code>&amp;</code> and <code>|</code>, not the short-circuiting scalar operators <code>&amp;&amp;</code> and <code>||</code> which are more useful inside if statements. Don’t forget <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan’s laws</a>, which can be useful to simplify negations:</p>
<ul>
<li><code>!(X &amp; Y)</code> is the same as <code>!X | !Y</code></li>
<li><code>!(X | Y)</code> is the same as <code>!X &amp; !Y</code></li>
</ul>
<p>For example, <code>!(X &amp; !(Y | Z))</code> simplifies to <code>!X | !!(Y|Z)</code>, and then to <code>!X | Y | Z</code>.</p>
<p><code>subset()</code> is a specialized shorthand function for subsetting data frames, and saves some typing because you don’t need to repeat the name of the data frame..</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">subset</span>(mtcars, gear <span class="op">==</span><span class="st"> </span><span class="dv">5</span>)
<span class="co">#&gt;                 mpg cyl  disp  hp drat   wt qsec vs am gear carb</span>
<span class="co">#&gt; Porsche 914-2  26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2</span>
<span class="co">#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2</span>
<span class="co">#&gt; Ford Pantera L 15.8   8 351.0 264 4.22 3.17 14.5  0  1    5    4</span>
<span class="co">#&gt; Ferrari Dino   19.7   6 145.0 175 3.62 2.77 15.5  0  1    5    6</span>
<span class="co">#&gt; Maserati Bora  15.0   8 301.0 335 3.54 3.57 14.6  0  1    5    8</span>

<span class="kw">subset</span>(mtcars, gear <span class="op">==</span><span class="st"> </span><span class="dv">5</span> <span class="op">&amp;</span><span class="st"> </span>cyl <span class="op">==</span><span class="st"> </span><span class="dv">4</span>)
<span class="co">#&gt;                mpg cyl  disp  hp drat   wt qsec vs am gear carb</span>
<span class="co">#&gt; Porsche 914-2 26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2</span>
<span class="co">#&gt; Lotus Europa  30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2</span></code></pre></div>
</div>
<div id="removing-columns-from-data-frames-character-subsetting" class="section level3">
<h3><span class="header-section-number">5.4.4</span> Removing columns from data frames (character subsetting)</h3>
<p>There are two ways to remove columns from a data frame. You can set individual columns to <code>NULL</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">y =</span> <span class="dv">3</span><span class="op">:</span><span class="dv">1</span>, <span class="dt">z =</span> letters[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])
df<span class="op">$</span>z &lt;-<span class="st"> </span><span class="ot">NULL</span></code></pre></div>
<p>Or you can subset to return only the columns you want:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">y =</span> <span class="dv">3</span><span class="op">:</span><span class="dv">1</span>, <span class="dt">z =</span> letters[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])
df[<span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>)]
<span class="co">#&gt;   x y</span>
<span class="co">#&gt; 1 1 3</span>
<span class="co">#&gt; 2 2 2</span>
<span class="co">#&gt; 3 3 1</span></code></pre></div>
<p>If you know the columns you don’t want, use set operations to work out which columns to keep:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df[<span class="kw">setdiff</span>(<span class="kw">names</span>(df), <span class="st">&quot;z&quot;</span>)]
<span class="co">#&gt;   x y</span>
<span class="co">#&gt; 1 1 3</span>
<span class="co">#&gt; 2 2 2</span>
<span class="co">#&gt; 3 3 1</span></code></pre></div>
</div>
<div id="random-samplesbootstrap-integer-subsetting" class="section level3">
<h3><span class="header-section-number">5.4.5</span> Random samples/bootstrap (integer subsetting)</h3>
<p>You can use integer indices to perform random sampling or bootstrapping of a vector or data frame. <code>sample()</code> generates a vector of indices, then subsetting accesses the values:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">each =</span> <span class="dv">2</span>), <span class="dt">y =</span> <span class="dv">6</span><span class="op">:</span><span class="dv">1</span>, <span class="dt">z =</span> letters[<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>]))
<span class="co">#&gt;   x y z</span>
<span class="co">#&gt; 1 1 6 a</span>
<span class="co">#&gt; 2 1 5 b</span>
<span class="co">#&gt; 3 2 4 c</span>
<span class="co">#&gt; 4 2 3 d</span>
<span class="co">#&gt; 5 3 2 e</span>
<span class="co">#&gt; 6 3 1 f</span>

<span class="co"># Randomly reorder</span>
df[<span class="kw">sample</span>(<span class="kw">nrow</span>(df)), ]
<span class="co">#&gt;   x y z</span>
<span class="co">#&gt; 5 3 2 e</span>
<span class="co">#&gt; 4 2 3 d</span>
<span class="co">#&gt; 1 1 6 a</span>
<span class="co">#&gt; 3 2 4 c</span>
<span class="co">#&gt; 6 3 1 f</span>
<span class="co">#&gt; 2 1 5 b</span>

<span class="co"># Select 3 random rows</span>
df[<span class="kw">sample</span>(<span class="kw">nrow</span>(df), <span class="dv">3</span>), ]
<span class="co">#&gt;   x y z</span>
<span class="co">#&gt; 6 3 1 f</span>
<span class="co">#&gt; 5 3 2 e</span>
<span class="co">#&gt; 3 2 4 c</span>

<span class="co"># Select 6 bootstrap replicates</span>
df[<span class="kw">sample</span>(<span class="kw">nrow</span>(df), <span class="dv">6</span>, <span class="dt">rep =</span> <span class="ot">TRUE</span>), ]
<span class="co">#&gt;     x y z</span>
<span class="co">#&gt; 2   1 5 b</span>
<span class="co">#&gt; 6   3 1 f</span>
<span class="co">#&gt; 3   2 4 c</span>
<span class="co">#&gt; 3.1 2 4 c</span>
<span class="co">#&gt; 6.1 3 1 f</span>
<span class="co">#&gt; 1   1 6 a</span></code></pre></div>
<p>The arguments of <code>sample()</code> control the number of samples to extract, and whether sampling is performed with or without replacement.</p>
</div>
<div id="boolean-algebra-vs.sets-logical-integer-subsetting" class="section level3">
<h3><span class="header-section-number">5.4.6</span> Boolean algebra vs. sets (logical &amp; integer subsetting)</h3>
<p>It’s useful to be aware of the natural equivalence between set operations (integer subsetting) and boolean algebra (logical subsetting). Using set operations is more effective when:</p>
<ul>
<li><p>You want to find the first (or last) <code>TRUE</code>.</p></li>
<li><p>You have very few <code>TRUE</code>s and very many <code>FALSE</code>s; a set representation may be faster and require less storage.</p></li>
</ul>
<p><code>which()</code> allows you to convert a boolean representation to an integer representation.</p>
<p>Let’s create two logical vectors and their integer equivalents and then explore the relationship between boolean and set operations.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(x1 &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span> <span class="op">%%</span><span class="st"> </span><span class="dv">2</span> <span class="op">==</span><span class="st"> </span><span class="dv">0</span>)
<span class="co">#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE</span>
(x2 &lt;-<span class="st"> </span><span class="kw">which</span>(x1))
<span class="co">#&gt; [1]  2  4  6  8 10</span>
(y1 &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span> <span class="op">%%</span><span class="st"> </span><span class="dv">5</span> <span class="op">==</span><span class="st"> </span><span class="dv">0</span>)
<span class="co">#&gt;  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE</span>
(y2 &lt;-<span class="st"> </span><span class="kw">which</span>(y1))
<span class="co">#&gt; [1]  5 10</span>

<span class="co"># X &amp; Y &lt;-&gt; intersect(x, y)</span>
x1 <span class="op">&amp;</span><span class="st"> </span>y1
<span class="co">#&gt;  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE</span>
<span class="kw">intersect</span>(x2, y2)
<span class="co">#&gt; [1] 10</span>

<span class="co"># X | Y &lt;-&gt; union(x, y)</span>
x1 <span class="op">|</span><span class="st"> </span>y1
<span class="co">#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE</span>
<span class="kw">union</span>(x2, y2)
<span class="co">#&gt; [1]  2  4  6  8 10  5</span>

<span class="co"># X &amp; !Y &lt;-&gt; setdiff(x, y)</span>
x1 <span class="op">&amp;</span><span class="st"> </span><span class="op">!</span>y1
<span class="co">#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE</span>
<span class="kw">setdiff</span>(x2, y2)
<span class="co">#&gt; [1] 2 4 6 8</span>

<span class="co"># xor(X, Y) &lt;-&gt; setdiff(union(x, y), intersect(x, y))</span>
<span class="kw">xor</span>(x1, y1)
<span class="co">#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE</span>
<span class="kw">setdiff</span>(<span class="kw">union</span>(x2, y2), <span class="kw">intersect</span>(x2, y2))
<span class="co">#&gt; [1] 2 4 6 8 5</span></code></pre></div>
<p>When first learning subsetting, a common mistake is to use <code>x[which(y)]</code> instead of <code>x[y]</code>. Here the <code>which()</code> achieves nothing: it switches from logical to integer subsetting but the result will be exactly the same. In more general cases, there are two important differences. First, when the logical vector contains NA, logical subsetting replaces these values by NA while <code>which()</code> drops these values. Second, <code>x[-which(y)]</code> is <strong>not</strong> equivalent to <code>x[!y]</code>: if <code>y</code> is all FALSE, <code>which(y)</code> will be <code>integer(0)</code> and <code>-integer(0)</code> is still <code>integer(0)</code>, so you’ll get no values, instead of all values. In general, avoid switching from logical to integer subsetting unless you want, for example, the first or last <code>TRUE</code> value.</p>
</div>
</div>
<div id="exercises-2" class="section level2">
<h2><span class="header-section-number">5.5</span> Exercises</h2>
<ol style="list-style-type: decimal">
<li>Install the tidyverse package, if you already have it installed upgrade to the latest version. This can be done by either typing <code>install.packages(&quot;tidyverse&quot;)</code> in the console or by using the “Packages” tab inside RStudio.</li>
</ol>
<p>The tideverse package is a collection of other packages and will take a while to install. Also, you may get an error that R could not move a file or package from a temporary directory to it’s final location. This happens because of our corporate virus scanner. The file is being virus scanned when R tries to move it. The simplest solution it reinstall just the offending package. You can also go to the temporary directory and manually move it via windows explorer.</p>
<ol start="2" style="list-style-type: decimal">
<li><p>Read <a href="http://vita.had.co.nz/papers/layered-grammar.pdf">A Layered Grammar of Graphics</a>. This is a shortish paper that introduces the concepts of the grammar of graphics and forms the basis for <code>ggplot</code>.</p></li>
<li><p>Read and do the exercises in Chapters 1-3 of <a href="http://r4ds.had.co.nz/">R for Data Science</a>.</p></li>
<li><p>Bring a couple example plots from out reports to next class. The goal is to have each of us work an a different type of plot so we can begin to build our plotting library.</p></li>
<li><p><code>which()</code> allows you to convert a boolean representation to an integer representation. There’s no reverse operation in base R. Create an <code>unwhich</code> function. <code>unwhich(which(x), length(x))</code> should return your original vector.</p></li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">10</span>) <span class="op">&lt;</span><span class="st"> </span><span class="dv">4</span>
<span class="kw">which</span>(x)

unwhich &lt;-<span class="st"> </span><span class="cf">function</span>(x, n) {
  <span class="co"># your code here</span>
}
<span class="kw">unwhich</span>(<span class="kw">which</span>(x), <span class="dv">10</span>)</code></pre></div>

</div>
</div>



            </section>

          </div>
        </div>
      </div>
<a href="base-r-data-structures.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="data-visualization.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": false,
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/DavisBrian/corporater/edit/master/subset.Rmd",
"text": "Edit"
},
"download": ["rclassnotes.pdf", "rclassnotes.epub"],
"toc": {
"collapse": "section"
},
"css": "corp.css"
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
