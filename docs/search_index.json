[
["relational-data.html", "8 Relational Data 8.1 Mutating Joins 8.2 Filtering Joins 8.3 Set Operations 8.4 Exercises", " 8 Relational Data library(tidyverse) Data analysis rarely involves only a single table of data. Typically you have multiple tables of data, which combined, answer the questions at hand. Collectively, multiple tables of data are called relational data because it is the relations, not just the individual data sets, that are important. Relations are always defined between a pair of tables. All other relations are built up from this simple idea. A key is a variable, or set of variables, that uniquely identifies an observation and links tables together. To work with relational data you need verbs that work with pairs of tables. There are three families of verbs designed to work with relational data: Mutating joins, which add new variables to one data frame from matching observations in another. Filtering joins, which filter observations from one data frame based on whether or not they match an observation in the other table. Set operations, which treat observations as if they were set elements. The most common place to find relational data is in a relational database management system (or RDBMS), a term that encompasses almost all modern databases. If you’ve used a database before, you’ve almost certainly used SQL. A key is a variable, or set of variables, that uniquely identifies an observation. x #&gt; # A tibble: 3 x 2 #&gt; key val_x #&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 1 x1 #&gt; 2 2 x2 #&gt; 3 3 x3 y #&gt; # A tibble: 3 x 2 #&gt; key val_y #&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 1 y1 #&gt; 2 2 y2 #&gt; 3 4 y3 8.1 Mutating Joins A mutating join allows you to combine variables from two tables. It first matches observations by their keys, then copies across variables from one table to the other. Like mutate(), the join functions add variables to the right, so if you have a lot of variables already, the new variables won’t get printed out. Inner Joins inner join keeps all observations in common between x and y inner_join(x, y) #&gt; Joining, by = &quot;key&quot; #&gt; # A tibble: 2 x 3 #&gt; key val_x val_y #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 x1 y1 #&gt; 2 2 x2 y2 By default the join functions will use all variables in common as the key. Best practice is to explicitly state the variables you wish to join by using the by parameter. Outer Joins left join keeps all observations in x append columns from y right join keeps all observations in y append columns from x full join keeps all observations in x and y left_join(x, y, by = &quot;key&quot;) #&gt; # A tibble: 3 x 3 #&gt; key val_x val_y #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 x1 y1 #&gt; 2 2 x2 y2 #&gt; 3 3 x3 &lt;NA&gt; right_join(x, y, by = &quot;key&quot;) #&gt; # A tibble: 3 x 3 #&gt; key val_x val_y #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 x1 y1 #&gt; 2 2 x2 y2 #&gt; 3 4 &lt;NA&gt; y3 full_join(x, y, by = &quot;key&quot;) #&gt; # A tibble: 4 x 3 #&gt; key val_x val_y #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 x1 y1 #&gt; 2 2 x2 y2 #&gt; 3 3 x3 &lt;NA&gt; #&gt; 4 4 &lt;NA&gt; y3 left_join and right_join are interchangeable with the arguments reversed. The only difference is the order of the columns in the resulting data frame. left_join(x, y, by = &quot;key&quot;) #&gt; # A tibble: 3 x 3 #&gt; key val_x val_y #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 x1 y1 #&gt; 2 2 x2 y2 #&gt; 3 3 x3 &lt;NA&gt; right_join(y, x, by = &quot;key&quot;) #&gt; # A tibble: 3 x 3 #&gt; key val_y val_x #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 y1 x1 #&gt; 2 2 y2 x2 #&gt; 3 3 &lt;NA&gt; x3 8.1.1 Duplicate keys There are many cases where a single key does not uniquely identify an observation. One-to-Many Many-to-Many 8.1.2 Multi-Column Keys By default all variables that are in both tables. To specify a subset of variables for the key use the by parameter. x &lt;- tribble( ~id, ~yq, ~question, 1, &quot;2018Q1&quot;, &quot;Yes&quot;, 1, &quot;2018Q2&quot;, &quot;No&quot;, 2, &quot;2018Q1&quot;, &quot;Yes&quot;, 3, &quot;2018Q1&quot;, &quot;Yes&quot;, 3, &quot;2018Q2&quot;, &quot;Yes&quot; ) y &lt;- tribble( ~id, ~yq, ~question, 1, &quot;2018Q2&quot;, &quot;Method1&quot;, 2, &quot;2018Q1&quot;, &quot;Method2&quot;, 2, &quot;2018Q2&quot;, &quot;Method2&quot;, 3, &quot;2018Q2&quot;, &quot;Method2&quot;, 4, &quot;2018Q1&quot;, &quot;Method1&quot; ) # full full_join(x, y) # probably not what we want #&gt; Joining, by = c(&quot;id&quot;, &quot;yq&quot;, &quot;question&quot;) #&gt; # A tibble: 10 x 3 #&gt; id yq question #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 2018Q1 Yes #&gt; 2 1 2018Q2 No #&gt; 3 2 2018Q1 Yes #&gt; 4 3 2018Q1 Yes #&gt; 5 3 2018Q2 Yes #&gt; 6 1 2018Q2 Method1 #&gt; # ... with 4 more rows full_join(x, y, by = c(&quot;id&quot;, &quot;yq&quot;)) #&gt; # A tibble: 7 x 4 #&gt; id yq question.x question.y #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 2018Q1 Yes &lt;NA&gt; #&gt; 2 1 2018Q2 No Method1 #&gt; 3 2 2018Q1 Yes Method2 #&gt; 4 3 2018Q1 Yes &lt;NA&gt; #&gt; 5 3 2018Q2 Yes Method2 #&gt; 6 2 2018Q2 &lt;NA&gt; Method2 #&gt; # ... with 1 more row 8.1.3 Duplicate Non-Key Columns By default if there are variables in both data frames that are not used as a key the common variables names will be appended with &quot;.x&quot; and &quot;.y&quot; corresponding the the first and second argument. If you want to change these use the suffix parameter. full_join(x, y, by = c(&quot;id&quot;, &quot;yq&quot;), suffix = c(&quot;_1&quot;, &quot;_2&quot;)) #&gt; # A tibble: 7 x 4 #&gt; id yq question_1 question_2 #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 2018Q1 Yes &lt;NA&gt; #&gt; 2 1 2018Q2 No Method1 #&gt; 3 2 2018Q1 Yes Method2 #&gt; 4 3 2018Q1 Yes &lt;NA&gt; #&gt; 5 3 2018Q2 Yes Method2 #&gt; 6 2 2018Q2 &lt;NA&gt; Method2 #&gt; # ... with 1 more row 8.1.4 Different Key Column Names A common occurrence is for the tables you wish to join to have different variable names. You can either change the variable names so the do match with rename() or you can use the by parameter to indicate which variable name in x matches the variable name in y. x &lt;- tribble( ~id, ~yq, ~question, 1, &quot;2018Q1&quot;, &quot;Yes&quot;, 1, &quot;2018Q2&quot;, &quot;No&quot;, 2, &quot;2018Q1&quot;, &quot;Yes&quot;, 3, &quot;2018Q1&quot;, &quot;Yes&quot;, 3, &quot;2018Q2&quot;, &quot;Yes&quot; ) y2 &lt;- tribble( ~id, ~yearquarter, ~question, 1, &quot;2018Q2&quot;, &quot;Method1&quot;, 2, &quot;2018Q1&quot;, &quot;Method2&quot;, 2, &quot;2018Q2&quot;, &quot;Method2&quot;, 3, &quot;2018Q2&quot;, &quot;Method2&quot;, 4, &quot;2018Q1&quot;, &quot;Method1&quot; ) # inner full_join(x, y2, by = c(&quot;id&quot;, &quot;yq&quot; = &quot;yearquarter&quot;), suffix = c(&quot;_1&quot;, &quot;_2&quot;)) #&gt; # A tibble: 7 x 4 #&gt; id yq question_1 question_2 #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 2018Q1 Yes &lt;NA&gt; #&gt; 2 1 2018Q2 No Method1 #&gt; 3 2 2018Q1 Yes Method2 #&gt; 4 3 2018Q1 Yes &lt;NA&gt; #&gt; 5 3 2018Q2 Yes Method2 #&gt; 6 2 2018Q2 &lt;NA&gt; Method2 #&gt; # ... with 1 more row 8.2 Filtering Joins Filtering joins match observations in the same way as mutating joins, but affect the observations, not the variables. There are two types: semi join keeps all observations in x that have a match in y anti join drops all observations in x that have a match in y Semi-joins are useful for matching filtered summary tables back to the original rows. The inverse of a semi-join is an anti-join. An anti-join keeps the rows that don’t have a match. Anti-joins are useful for diagnosing join mismatches. orig &lt;- tribble( ~id, ~yq, ~question, 1, &quot;2018Q1&quot;, &quot;Yes&quot;, 1, &quot;2018Q2&quot;, &quot;No&quot;, 2, &quot;2018Q1&quot;, &quot;Yes&quot;, 3, &quot;2018Q1&quot;, &quot;Yes&quot;, 3, &quot;2018Q2&quot;, &quot;Yes&quot; ) val &lt;- tribble( ~id, ~yq, ~question, 1, &quot;2018Q1&quot;, &quot;No&quot;, 1, &quot;2018Q2&quot;, &quot;No&quot;, 2, &quot;2018Q1&quot;, &quot;Yes&quot;, 3, &quot;2018Q3&quot;, &quot;No&quot;, 3, &quot;2018Q2&quot;, &quot;Yes&quot; ) semi_join(orig, val, by = c(&quot;id&quot;, &quot;yq&quot;, &quot;question&quot;)) #&gt; # A tibble: 3 x 3 #&gt; id yq question #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 2018Q2 No #&gt; 2 2 2018Q1 Yes #&gt; 3 3 2018Q2 Yes anti_join(orig, val, by = c(&quot;id&quot;, &quot;yq&quot;, &quot;question&quot;)) #&gt; # A tibble: 2 x 3 #&gt; id yq question #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 2018Q1 Yes #&gt; 2 3 2018Q1 Yes 8.3 Set Operations The final type of two-table verb are the set operations. These operations work with a complete row, comparing the values of every variable. These expect the x and y inputs to have the same variables, in the same order, and treat the observations like sets: intersect(x, y): return only observations in both x and y. union(x, y): return unique observations in x and y. setdiff(x, y): return observations in x, but not in y. Given this simple data: df1 &lt;- tribble( ~x, ~y, 1, 1, 2, 1 ) df2 &lt;- tribble( ~x, ~y, 1, 1, 1, 2 ) The four possibilities are: intersect(df1, df2) #&gt; # A tibble: 1 x 2 #&gt; x y #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 # Note that we get 3 rows, not 4 union(df1, df2) #&gt; # A tibble: 3 x 2 #&gt; x y #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 2 #&gt; 2 2 1 #&gt; 3 1 1 setdiff(df1, df2) #&gt; # A tibble: 1 x 2 #&gt; x y #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2 1 setdiff(df2, df1) #&gt; # A tibble: 1 x 2 #&gt; x y #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 2 8.4 Exercises Continue the exercises from last week. (See email) We have a survey in which the survey, questions, answers, and respondents demographics are stored in separate data sets (see below code). Generate a single analysis data set which contains every persons, with their demographic information, and their response to all questions. If they do not have a response to a question mark it as “No Response”. subjects &lt;- tribble( ~id, ~gender, ~age, 101L, &quot;M&quot;, 25L, 102L, &quot;F&quot;, 40L, 103L, &quot;F&quot;, 18L, 104L, &quot;M&quot;, 57L ) answers &lt;- tribble( ~id, ~qid, ~answer, 101L, 1L, &quot;Yes&quot;, 101L, 2L, &quot;No&quot;, 102L, 1L, &quot;No&quot;, 102L, 2L, &quot;Yes&quot;, 102L, 4L, &quot;Yes&quot;, 103L, 1L, &quot;No&quot;, 103L, 2L, &quot;No&quot;, 103L, 3L, &quot;No&quot; ) survey &lt;- tribble( ~qid, ~question, 1L , &quot;Have you ever used Product A?&quot;, 2L , &quot;Have you ever used Product B?&quot;, 3L , &quot;Have you ever used Product C?&quot;, 4L , &quot;Have you ever used Product D?&quot; ) The resulting data set should look like #&gt; # A tibble: 16 x 6 #&gt; id qid question answer gender age #&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 101 1 Have you ever used Product A? Yes M 25 #&gt; 2 101 2 Have you ever used Product B? No M 25 #&gt; 3 101 3 Have you ever used Product C? No Response M 25 #&gt; 4 101 4 Have you ever used Product D? No Response M 25 #&gt; 5 102 1 Have you ever used Product A? No F 40 #&gt; 6 102 2 Have you ever used Product B? Yes F 40 #&gt; # ... with 10 more rows From the above data set what is the mean age of those answering “Yes”, “No”, “No Response”, for each equstion? Repeat by gender "]
]
