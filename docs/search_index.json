[
["r-basics.html", "Chapter 3 R Basics 3.1 Assignment Operators 3.2 Objects 3.3 Comparision 3.4 Logical and sets 3.5 Control Structures 3.6 Vectorization &amp; Recycling 3.7 Function Basics 3.8 Environments &amp; Scoping 3.9 Assignment", " Chapter 3 R Basics With over 10,000 packages on CRAN we can’t cover everything. In general there are several ways, or packages, to accomplish a given task. Here is a quick look at some of the basics. Next we’ll dive deep into R’s basic data structures and how to subset them in subsequent chapters. This will give us a good overview of base R and the background needed to dive into R for Data Science. The three most important functions in R ?, ??, and str: ?topic provides access to the documentation for topic. ??topic searches the documention for topic. str displays the structure of an R object in human readable form. See this vocabulary list for a good starting point on the basics functions in base R and some important libraries. A book to learn the basics is R Programmig for Data Science In R there three basic constructs; objects, functions, and environments: 3.1 Assignment Operators We saw this is Coding Style. Use &lt;- for assignment and use = for parameters. While you can use = for assignment it is generally considered bad practice. 3.2 Objects 3.2.1 Vector You create a vector with c. v &lt;- c(&quot;my&quot;, &quot;first&quot;, &quot;vector&quot;) v #&gt; [1] &quot;my&quot; &quot;first&quot; &quot;vector&quot; # length of our vector length(v) #&gt; [1] 3 There are several shortcut functions for common vector creation. # create an ordered sequence 2:10 #&gt; [1] 2 3 4 5 6 7 8 9 10 9:3 #&gt; [1] 9 8 7 6 5 4 3 # generate regular sequences seq(1, 5, by = 3) #&gt; [1] 1 4 # replicate a number n times rep(3, times = 4) #&gt; [1] 3 3 3 3 # common mistake using 1:length(n) in loops # but if n = 0 1:0 #&gt; [1] 1 0 # use seq_len(n) instead and the loop won&#39;t execute seq_len(0) #&gt; integer(0) # another common mistake n &lt;- 6 1:n+1 # is (1:n) + 1, so 2:(n + 1) #&gt; [1] 2 3 4 5 6 7 1:(n+1) # usually what is meant #&gt; [1] 1 2 3 4 5 6 7 seq_len(n+1) # another way #&gt; [1] 1 2 3 4 5 6 7 3.2.2 Matrix Matrices are 2D vectors, with all elements of the same type. Genearlly used for mathematics. # fill in column order (default) matrix(1:12, nrow = 3) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 # fill in row order matrix(1:12, nrow = 3, byrow = TRUE) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 2 3 4 #&gt; [2,] 5 6 7 8 #&gt; [3,] 9 10 11 12 # can also specify the number of columns instead matrix(1:12, ncol = 3) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 You find the dimensions of a matrix with nrow, ncol, and dim m &lt;- matrix(1:12, ncol = 3) dim(m) #&gt; [1] 4 3 nrow(m) #&gt; [1] 4 ncol(m) #&gt; [1] 3 3.2.3 List A list is a generic vector containing other objects. These do NOT have to be the same type or the same length. s &lt;- c(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;, &quot;ee&quot;) b &lt;- c(TRUE, FALSE, TRUE, FALSE, FALSE) # x contains copies of n, s, b and our matrix from above x &lt;- list(n = c(2, 3, 5) , s, b, 3, m) x #&gt; $n #&gt; [1] 2 3 5 #&gt; #&gt; [[2]] #&gt; [1] &quot;aa&quot; &quot;bb&quot; &quot;cc&quot; &quot;dd&quot; &quot;ee&quot; #&gt; #&gt; [[3]] #&gt; [1] TRUE FALSE TRUE FALSE FALSE #&gt; #&gt; [[4]] #&gt; [1] 3 #&gt; #&gt; [[5]] #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 # length gives you length of the list not the elements in the list length(x) #&gt; [1] 5 We’ll discuss lists in detail in the next chapter. 3.2.4 Data frame A data frame is a list with each vector of the same length. This is the main data structure used and is analagous to a data set in SAS. While these look like matrices they behave very different. df = data.frame(n = c(2, 3, 5), s = c(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;), b = c(TRUE, FALSE, TRUE), y = v ) # df is a data frame df #&gt; n s b y #&gt; 1 2 aa TRUE my #&gt; 2 3 bb FALSE first #&gt; 3 5 cc TRUE vector # dimensions dim(df) #&gt; [1] 3 4 nrow(df) #&gt; [1] 3 ncol(df) #&gt; [1] 4 length(df) #&gt; [1] 4 We’ll discuss data frames in great detail in the next chapter. 3.3 Comparision Logical Operators include: Operator Description &gt; greater than &gt;= greater than or equal to &lt; less than &lt;= less than or equal to == exactly equal to != not equal to v &lt;- 1:12 v[v &gt; 9] #&gt; [1] 10 11 12 Equality can be tricky to test for since real numbers can’t be expressed exactly in computers. x &lt;- sqrt(2) (y &lt;- x^2) #&gt; [1] 2 y == 2 #&gt; [1] FALSE print(y, digits = 20) #&gt; [1] 2.0000000000000004 all.equal(y, 2) ## equality with some tolerance #&gt; [1] TRUE all.equal(y, 3) #&gt; [1] &quot;Mean relative difference: 0.5&quot; isTRUE(all.equal(y, 3)) ## if you want a boolean, use isTRUE() #&gt; [1] FALSE 3.4 Logical and sets x &lt;- c(TRUE, FALSE) df &lt;- data.frame(expand.grid(x, x)) names(df) &lt;- c(&quot;x&quot;, &quot;y&quot;) df$and &lt;- df$x &amp; df$y # logical and df$or &lt;- df$x | df$y # logical or df$notx &lt;- !df$x # negation df$xor &lt;- xor(df$x, df$y) # exlusive or df #&gt; x y and or notx xor #&gt; 1 TRUE TRUE TRUE TRUE FALSE FALSE #&gt; 2 FALSE TRUE FALSE TRUE TRUE TRUE #&gt; 3 TRUE FALSE FALSE TRUE FALSE TRUE #&gt; 4 FALSE FALSE FALSE FALSE TRUE FALSE R has two versions of the logical operators &amp; and &amp;&amp; (| and ||). The single version is the vectorized version while the the double version returns a length-one vector. Use the double version in logical control structures (if, for, while, etc). # TRUE/FALSE and each element TRUE &amp; c(TRUE, FALSE) #&gt; [1] TRUE FALSE FALSE &amp; c(TRUE, FALSE) #&gt; [1] FALSE FALSE # TRUE/FALSE and first element TRUE &amp;&amp; c(TRUE, FALSE) #&gt; [1] TRUE FALSE &amp;&amp; c(TRUE, FALSE) #&gt; [1] FALSE # TRUE/FALSE or each element TRUE | c(TRUE, FALSE) #&gt; [1] TRUE TRUE FALSE | c(TRUE, FALSE) #&gt; [1] TRUE FALSE # TRUE/FALSE or first element TRUE || c(TRUE, FALSE) #&gt; [1] TRUE FALSE || c(TRUE, FALSE) #&gt; [1] TRUE This is a common source of bugs in control structures (if, for, while, etc) where you must have a single TRUE / FALSE. Also, note that = is used for assignment and not comparison ==. It also has useful helpers any and all x &lt;- c(FALSE, FALSE, FALSE, TRUE) any(x) #&gt; [1] TRUE all(x) #&gt; [1] FALSE all(!x[1:3]) #&gt; [1] TRUE And also some useful set operations intersect, union, setdiff, setequal x &lt;- 1:5 y &lt;- 3:7 intersect(x, y) # in x and in y #&gt; [1] 3 4 5 union(x, y) # different than c() #&gt; [1] 1 2 3 4 5 6 7 c(x,y) # not a set operation #&gt; [1] 1 2 3 4 5 3 4 5 6 7 setdiff(x, y) # in x but not in y #&gt; [1] 1 2 setdiff(y, x) # in y but not in x #&gt; [1] 6 7 setequal(x, y) #&gt; [1] FALSE z &lt;- 5:1 setequal(x, z) #&gt; [1] TRUE 3.5 Control Structures Control structures allow you to put some “logic” into your R code, rather than just always executing the same R code every time. Control structures allow you to respond to inputs or to features of the data and execute different R expressions accordingly. Commonly used control structures are if and else: testing a condition and acting on it for: execute a loop a fixed number of times while: execute a loop while a condition is true repeat: execute an infinite loop (must break out of it to stop) break: break the execution of a loop next: skip an interation of a loop 3.5.1 if-else The if-else combination is probably the most commonly used control structure in R (or perhaps any language). This structure allows you to test a condition and act on it depending on whether it’s true or false. For starters, you can just use the if statement. if(&lt;condition&gt;) { # do something } # Continue with rest of code The above code does nothing if the condition is false. If you have an action you want to execute when the condition is false, then you need an else clause. if(&lt;condition&gt;) { # do something } else { # do something else } You can have a series of tests by following the initial if with any number of else ifs. if(&lt;condition1&gt;) { # do something } else if(&lt;condition2&gt;) { # do something different } else { # do something else different } 3.5.2 for Loops For loops are pretty much the only looping construct that you will need in R. While you may occasionally find a need for other types of loops, in my experience doing data analysis, I’ve found very few situations where a for loop wasn’t sufficient. In R, for loops take an interator variable and assign it successive values from a sequence or vector. For loops are most commonly used for iterating over the elements of an object (list, vector, etc.) The following three loops all have the similar behavior. x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) for(i in 1:length(x)) { ## Print out each element of &#39;x&#39; print(x[i]) } #&gt; [1] &quot;a&quot; #&gt; [1] &quot;b&quot; #&gt; [1] &quot;c&quot; #&gt; [1] &quot;d&quot; The seq_along() function is commonly used in conjunction with for loops in order to generate an integer sequence based on the length of an object (in this case, the object x). ## Generate a sequence based on length of &#39;x&#39; for(i in seq_along(x)) { print(x[i]) } #&gt; [1] &quot;a&quot; #&gt; [1] &quot;b&quot; #&gt; [1] &quot;c&quot; #&gt; [1] &quot;d&quot; It is not necessary to use an index-type variable. for(letter in x) { print(letter) } #&gt; [1] &quot;a&quot; #&gt; [1] &quot;b&quot; #&gt; [1] &quot;c&quot; #&gt; [1] &quot;d&quot; Try these examples above but with x &lt;- NULL and notice the difference in behavior. Nested loops are commonly needed for multidimensional or hierarchical data structures (e.g. matrices, lists). Be careful with nesting though. Nesting beyond 2 to 3 levels often makes it difficult to read/understand the code. If you find yourself in need of a large number of nested loops, you may want to break up the loops by using functions (discussed later). 3.5.3 while Loops While loops begin by testing a condition. If it is true, then they execute the loop body. Once the loop body is executed, the condition is tested again, and so forth, until the condition is false, after which the loop exits. count &lt;- 0 while(count &lt; 10) { print(count) count &lt;- count + 1 } #&gt; [1] 0 #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 #&gt; [1] 6 #&gt; [1] 7 #&gt; [1] 8 #&gt; [1] 9 While loops can potentially result in infinite loops if not written properly. Use with care! Sometimes there will be more than one condition in the test. z &lt;- 5 set.seed(1) while(z &gt;= 3 &amp;&amp; z &lt;= 10) { coin &lt;- rbinom(1, 1, 0.5) if(coin == 1) { ## random walk z &lt;- z + 1 } else { z &lt;- z - 1 } } print(z) #&gt; [1] 2 Conditions are always evaluated from left to right. For example, in the above code, if z were less than 3, the second test would not have been evaluated. 3.5.4 repeat Loops repeat initiates an infinite loop right from the start. These are not commonly used in statistical or data analysis applications but they do have their uses. The only way to exit a repeat loop is to call break. One possible paradigm might be in an iterative algorith where you may be searching for a solution and you don’t want to stop until you’re close enough to the solution. In this kind of situation, you often don’t know in advance how many iterations it’s going to take to get “close enough” to the solution. x0 &lt;- 1 tol &lt;- 1e-8 repeat { x1 &lt;- computeEstimate() if(abs(x1 - x0) &lt; tol) { ## Close enough? break } else { x0 &lt;- x1 } } Note that the above code will not run if the computeEstimate() function is not defined (I just made it up for the purposes of this demonstration). The loop above is a bit dangerous because there’s no guarantee it will ever stop. You could get in a situation where the values of x0 and x1 oscillate back and forth and never converge. Better to set a hard limit on the number of iterations by using a for loop and then report whether convergence was achieved or not. 3.5.5 next, break While not used very often it’s nice to know about these. next is used to skip an iteration of a loop. for(i in 1:100) { if(i &lt;= 20) { ## Skip the first 20 iterations next } ## Do something here } break is used to exit a loop immediately, regardless of what iteration the loop may be on. for(i in 1:100) { print(i) if(i &gt; 20) { ## Stop loop after 20 iterations break } } 3.5.6 Looping For loops are so common that that R has some functions which implement looping in a compact form to make your life easier. For a more in depth look see this apply is generic: applies a function to a matrix’s rows or columns (or, more generally, to dimensions of an array) lapply is a list apply which acts on a list or vector and returns a list. sapply is a simple lapply but defaults to returning a vector (or matrix) if possible. vapply is a verified apply. This is a sapply with the return object type prespecified. rapply is a recursive apply for nested lists, i.e. lists within lists tapply is a tagged apply where the tags identify the subsets to apply a function mapply is a multivariabe apply for functions that have multiple arguments. Map is a wrapper to mapply with SIMPLIFY = FALSE, so it is guaranteed to return a list. replicate is a wrapper around sapply for repeated evaluation of an expression # Two dimensional matrix M &lt;- matrix(seq(1,16), 4, 4) M #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 5 9 13 #&gt; [2,] 2 6 10 14 #&gt; [3,] 3 7 11 15 #&gt; [4,] 4 8 12 16 # apply min to rows apply(M, 1, min) #&gt; [1] 1 2 3 4 # apply max to columns apply(M, 2, max) #&gt; [1] 4 8 12 16 If you want row/column means or sums for a 2D matrix, be sure to investigate the highly optimized, lightning-quick colMeans, rowMeans, colSums, rowSums. x &lt;- list(a = 1, b = 1:3, c = 10:25) x #&gt; $a #&gt; [1] 1 #&gt; #&gt; $b #&gt; [1] 1 2 3 #&gt; #&gt; $c #&gt; [1] 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 lapply(x, FUN = length) #&gt; $a #&gt; [1] 1 #&gt; #&gt; $b #&gt; [1] 3 #&gt; #&gt; $c #&gt; [1] 16 sapply(x, FUN = length) #&gt; a b c #&gt; 1 3 16 vapply(x, FUN = length, FUN.VALUE = 0L) #&gt; a b c #&gt; 1 3 16 x &lt;- 1:20 y &lt;- factor(rep(letters[1:5], each = 4)) # a vector of the same length as x tapply(x, y, sum) #&gt; a b c d e #&gt; 10 26 42 58 74 # Sums the 1st elements, the 2nd elements, etc. mapply(sum, 1:5, 1:5, 1:5) #&gt; [1] 3 6 9 12 15 # find the mean of 10 random normal variables, 5 times replicate(5, mean(rnorm(10))) #&gt; [1] 0.009560203 -0.082577193 0.032326586 0.192819739 -0.432339116 tapply is in a simalar spirit to a common data analysis paradigm called split-apply-combine where we split our data set based on a group, apply a function or code to it, and combine the results back together. We will revisit this paradigm in greater detail when we get to R for Data Science. 3.6 Vectorization &amp; Recycling Many operations in R are vectorized, meaning that operations occur in parallel in certain R objects. This allows you to write code that is efficient, concise, and easier to read than in non-vectorized languages. The simplest example is when adding two vectors together. x &lt;- 1:3 y &lt;- 11:13 z &lt;- x + y z #&gt; [1] 12 14 16 In most other languages you would have to do something like z &lt;- numeric(length(x)) for(i in seq_along(x)) { z[i] &lt;- x[i] + y[i] } z #&gt; [1] 12 14 16 We saw a a form of vectorization above in the logical operators. x #&gt; [1] 1 2 3 x &gt; 2 #&gt; [1] FALSE FALSE TRUE x[x &gt; 2] #&gt; [1] 3 Matrix operations are also vectorized, making for nice compact notation. This way, we can do element-by-element operations on matrices without having to loop over every element. x &lt;- matrix(1:4, 2, 2) y &lt;- matrix(rep(10, 4), 2, 2) x #&gt; [,1] [,2] #&gt; [1,] 1 3 #&gt; [2,] 2 4 y #&gt; [,1] [,2] #&gt; [1,] 10 10 #&gt; [2,] 10 10 x * y # element-wise multiplication #&gt; [,1] [,2] #&gt; [1,] 10 30 #&gt; [2,] 20 40 x / y # element-wise division #&gt; [,1] [,2] #&gt; [1,] 0.1 0.3 #&gt; [2,] 0.2 0.4 x %*% y # true matrix multiplication #&gt; [,1] [,2] #&gt; [1,] 40 40 #&gt; [2,] 60 60 R also recyles arguments. x &lt;- 1:10 z &lt;- x + .1 # add .1 to each element z #&gt; [1] 1.1 2.1 3.1 4.1 5.1 6.1 7.1 8.1 9.1 10.1 While you usually either want the same length vector or a length one vector. You are not limited to just these options. x &lt;- 1:10 y &lt;- x + c(.1, .2) y #&gt; [1] 1.1 2.2 3.1 4.2 5.1 6.2 7.1 8.2 9.1 10.2 z &lt;- x + c(.1, .2, .3) #&gt; Warning in x + c(0.1, 0.2, 0.3): longer object length is not a multiple of shorter object length z #&gt; [1] 1.1 2.2 3.3 4.1 5.2 6.3 7.1 8.2 9.3 10.1 3.6.1 Example One (not so good) way to estimate pi is through Monte-Carlo simulation. Suppose we wish to estimate the value of pi using a Monte-Carlo method. Esentially, we throw darts at the unit square and count the number of darts that fall within the unit circle. We’ll only deal with quadrant one. Thus the \\(Area = \\frac{\\pi}{4}\\) Monte-Carlo psuedo code: Initalize hits = 0 for i in 1:N Generate two random numbers, \\(U_1\\) and \\(U_2\\), between 0 and 1 If \\(U_1^2 + U_2^2 &lt; 1\\), then hits = hits + 1 end for Area estimate = hits / N \\(\\hat{pi} = 4 * Area Estimate\\) pi_naive &lt;- function(N) { hits &lt;- 0 for(i in seq_len(N)) { U1 &lt;- runif(1) U2 &lt;- runif(1) if ((U1^2 + U2^2) &lt; 1) { hits &lt;- hits + 1 } } 4*hits/N } N &lt;- 1e6 system.time(pi_naive(N)) #&gt; user system elapsed #&gt; 3.29 0.00 3.33 That’s a long runtime (and bad estimate). Let’s vecrtorize it. pi_vect &lt;- function(N) { U1 &lt;- runif(N) U2 &lt;- runif(N) hits &lt;- sum(U1^2 + U2^2 &lt; 1) 4*hits/N } system.time(pi_vect(N)) #&gt; user system elapsed #&gt; 0.18 0.00 0.17 3.7 Function Basics To understand computations in R, two slogans are helpful: - Everything that exists is an object. - Everything that happens is a function call. John Chambers Functions in R are “first class objects”, which means that they can be treated much like any other R object. Importantly, Functions can be passed as arguments to other functions. This is very handy for the various apply functions, like lapply() and sapply(). Functions can be nested, so that you can define a function inside of another function If you’re familiar with common language like C, these features might appear a bit strange. However, they are really important in R and can be useful for data analysis. Messy code hides bugs Functions are a means of abstraction. A concept/computation is encapsulated/isolated from the rest with a function. Functions should do one thing, and do it well (compute, or plot, or save, … not all in one go). Side effects: your functions should not have any (unless, of course, that is the main point of that function - plotting, write to disk, …). Functions shouldn’t make any changes in any environment. The only return their output. Do not use global variables. Everything the function needs is being passed as an argument. Function must be self-contained. Function streamline code and process From the R Inferno: Make your functions as simple as possible. Simple has many advantages: Simple functions are likely to be human efficient: they will be easy to understand and to modify. Simple functions are likely to be computer efficient. Simple functions are less likely to be buggy, and bugs will be easier to fix. (Perhaps ironically) simple functions may be more general—thinking about the heart of the matter often broadens the application. Functions can be Correct. An error occurs that is clearly identified. An obscure error occurs. An incorrect value is returned. We like category 1. Category 2 is the right behavior if the inputs do not make sense, but not if the inputs are sensible. Category 3 is an unpleasant place for your users, and possibly for you if the users have access to you. Category 4 is by far the worst place to be - the user has no reason to believe that anything is wrong. Steer clear of category 4. Finally, functions are Easier to debug Easier to profile Easier to parallelise Functions are an central part of robust R programming and we will spend a significant amount of time writing functions. 3.7.1 Your First Function All R functions have three parts: the body(), the code inside the function. the formals(), the list of arguments which controls how you can call the function. the environment(), the “map” of the location of the function’s variables. When you print a function in R, it shows you these three important components. If the environment isn’t displayed, it means that the function was created in the global environment. myadd &lt;- function(x, y) { cat(paste0(&quot;x = &quot;, x, &quot;\\n&quot;)) cat(paste0(&quot;y = &quot;, y, &quot;\\n&quot;)) x + y } myadd(1, 3) # call by position #&gt; x = 1 #&gt; y = 3 #&gt; [1] 4 myadd(x = 1, y = 3) # call by name #&gt; x = 1 #&gt; y = 3 #&gt; [1] 4 myadd(y = 3, x = 1) # name order doesn&#39;t matter #&gt; x = 1 #&gt; y = 3 #&gt; [1] 4 The body of the function is everything between the { }. Note this does the computation AND returns the result. x and y are the arguments to the function. the environment this function lives in is the global environement. (We’ll discuss environments more in the next section.) Even though it’s legal, I don’t recommend messing around with the order of the arguments too much, since it can lead to some confusion. You can also specify default values for your arguments. Default values should be the values most often used. rnorm uses the default of mean = 0 and sd = 1. We usually want to sample from the standard normal distribution, but we are not forced to. myadd2 &lt;- function(x = 3, y = 0){ cat(paste0(&quot;x = &quot;, x, &quot;\\n&quot;)) cat(paste0(&quot;y = &quot;, y, &quot;\\n&quot;)) x + y } myadd2() # use the defaults #&gt; x = 3 #&gt; y = 0 #&gt; [1] 3 myadd2(x = 1) #&gt; x = 1 #&gt; y = 0 #&gt; [1] 1 myadd2(y = 1) #&gt; x = 3 #&gt; y = 1 #&gt; [1] 4 myadd2(x = 1, y = 1) #&gt; x = 1 #&gt; y = 1 #&gt; [1] 2 By defualt the last line of the function is returned. Thus, there is no reason to explicitly call return, unless you are returning from the function early. Inside functions use stop to return error messages, warning to return warning messages, and message to print a message to the console. f &lt;- function(age) { if (age &lt; 0) { stop(&quot;age must be a positive number&quot;) } if (age &lt; 18) { warning(&quot;Check your data. We only care about adults.&quot;) } message(paste0(&quot;Your person is &quot;, age, &quot; years old&quot;)) invisible() } f(-10) #&gt; Error in f(-10): age must be a positive number f(10) #&gt; Warning in f(10): Check your data. We only care about adults. #&gt; Your person is 10 years old f(30) #&gt; Your person is 30 years old 3.7.2 Lazy Evaluation R is lazy. Arguments to functions are evaluated lazily, that is they are evaluated only as needed in the body of the function. In this example, the function f() has two arguments: a and b. f &lt;- function(a, b) { a^2 } f(2) # this works #&gt; [1] 4 f(2, 1) # this does too #&gt; [1] 4 This function never actually uses the argument b, so calling f(2) or f(2, 1) will not produce an error because the 2 gets positionally matched to a. This behavior can be good or bad. It’s common to write a function that doesn’t use an argument and not notice it simply because R never throws an error. 3.7.3 The ... Argument There is a special argument in R known as the ... argument, which indicate a variable number of arguments that are usually passed on to other functions. The ... argument is often used when extending another function and you don’t want to copy the entire argument list of the original function For example, a custom plotting function may want to make use of the default plot() function along with its entire argument list. The function below changes the default for the type argument to the value type = &quot;l&quot; (the original default was type = &quot;p&quot;). myplot &lt;- function(x, y, type = &quot;l&quot;, ...) { plot(x, y, type = type, ...) ## Pass &#39;...&#39; to &#39;plot&#39; function } The ... argument is also necessary when the number of arguments passed to the function cannot be known in advance. This is clear in functions like paste() and cat(). args(paste) #&gt; function (..., sep = &quot; &quot;, collapse = NULL) #&gt; NULL args(cat) #&gt; function (..., file = &quot;&quot;, sep = &quot; &quot;, fill = FALSE, labels = NULL, #&gt; append = FALSE) #&gt; NULL Because both paste() and cat() print out text to the console by combining multiple character vectors together, it is impossible for those functions to know in advance how many character vectors will be passed to the function by the user. So the first argument to either function is .... One catch with ... is that any arguments that appear after ... on the argument list must be named explicitly and cannot be partially matched or matched positionally. Take a look at the arguments to the paste() function. args(paste) #&gt; function (..., sep = &quot; &quot;, collapse = NULL) #&gt; NULL With the paste() function, the arguments sep and collapse must be named explicitly and in full if the default values are not going to be used. 3.8 Environments &amp; Scoping An environment is a collection of (symbol, value) pairs, i.e. x is a symbol and 3.14 might be its value. Every environment has a parent environment and it is possible for an environment to have multiple “children”. The only environment without a parent is the empty environment. Scoping is the set of rules that govern how R looks up the value of a symbol. In the example below, scoping is the set of rules that R applies to go from the symbol x to its value 10: x &lt;- 10 x #&gt; [1] 10 R has two types of scoping: lexical scoping, implemented automatically at the language level, and dynamic scoping, used in select functions to save typing during interactive analysis. We discuss lexical scoping here because it is intimately tied to function creation. Dynamic scoping is an advanced topic and is discussed in Advanced R. How do we associate a value to a free variable? There is a search process that occurs that goes as follows: If the value of a symbol is not found in the environment in which a function was defined, then the search is continued in the parent environment. The search continues up the sequence of parent environments until we hit the top-level environment; this usually the global environment (workspace) or the namespace of a package. After the top-level environment, the search continues down the search list until we hit the empty environment. If a value for a given symbol cannot be found once the empty environment is arrived at, then an error is thrown. x &lt;- 0 f &lt;- function(x = -1) { x &lt;- 1 y &lt;- 2 c(x, y) } g &lt;- function(x = -1) { y &lt;- 1 c(x, y) } h &lt;- function() { y &lt;- 1 c(x, y) } What do the following return? f() g() h() g(h()) f(g()) g(f()) Unlike most languages you can define a function within a function. This nested function only lives inside the parent function. make.power &lt;- function(n) { pow &lt;- function(x) { x^n } pow } make.power(4) #&gt; function(x) { #&gt; x^n #&gt; } #&gt; &lt;environment: 0x00000000082fe9b8&gt; cube &lt;- make.power(3) square &lt;- make.power(2) x &lt;- 1 n &lt;- 2 pow(x=4) #&gt; Error in pow(x = 4): could not find function &quot;pow&quot; 3.9 Assignment Browse this vocabulary list and read the help file for functions that interest you. Vectorization / function practice. We’ll calcualte pi using the Gregory-Leibniz series. Mathematicians will be quick to point out that this is a poor way to calculate pi, since the series converges very slowly. But our goal is not calculating pi, our goal is examining the performance benefit that be be achieved using vectorization. Here is a formula for the Gregory-Leibniz series: \\(1 - 1/3 + 1/5 - 1/7 + 1/9 - ... = \\frac{\\pi}{4}\\) Here is the Gregory-Leibniz series in summation notation: $ {n=0}^{} = $ The straightforward implementation using an R loop would look like this: GL_naive &lt;- function (limit) { p = 0 for (n in 0:limit) { p = (-1)^n/(2 * n + 1) + p } 4*p } N &lt;- 1e7 system.time(pi_est &lt;- GL_naive(N)) #&gt; user system elapsed #&gt; 2.10 0.00 2.14 pi_est #&gt; [1] 3.141593 Your take is to vectorize this function. Do not use any looping or apply functions. This one is a bit tricky. Hint: It may be easier to think about it in terms of the series notation and not the summation notation. GL_vect &lt;- function(limit) { # your code here # use only base functions and no looping mechanisms } "]
]
